{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,6KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/automated-workflow-with-code-bot-fsm.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agentic workflow assistant using Finite State Machines (FSM). This file exports the\n * `automatedWorkflowWithCodeBotFSM` function, which enables developers to build more productive and reliable AI-assisted\n * coding workflows by defining and managing states, transitions, and actions within a Genkit flow.\n *\n * - automatedWorkflowWithCodeBotFSM - The main function to orchestrate the FSM-driven coding workflow.\n * - AutomatedWorkflowWithCodeBotFSMInput - The input type for the automatedWorkflowWithCodeBotFSM function.\n * - AutomatedWorkflowWithCodeBotFSMOutput - The return type for the automatedWorkflowWithCodeBotFSM function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst AutomatedWorkflowWithCodeBotFSMInputSchema = z.object({\n  taskDescription: z.string().describe('The description of the coding task to be performed.'),\n});\nexport type AutomatedWorkflowWithCodeBotFSMInput = z.infer<typeof AutomatedWorkflowWithCodeBotFSMInputSchema>;\n\nconst AutomatedWorkflowWithCodeBotFSMOutputSchema = z.object({\n  generatedCode: z.string().describe('The final generated code from the FSM-driven workflow.'),\n  workflowSummary: z.string().describe('A summary of the steps and states traversed during the workflow.'),\n});\nexport type AutomatedWorkflowWithCodeBotFSMOutput = z.infer<typeof AutomatedWorkflowWithCodeBotFSMOutputSchema>;\n\nexport async function automatedWorkflowWithCodeBotFSM(input: AutomatedWorkflowWithCodeBotFSMInput): Promise<AutomatedWorkflowWithCodeBotFSMOutput> {\n  return automatedWorkflowWithCodeBotFSMFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'codeBotFSMPrompt',\n  input: {\n    schema: z.object({\n      taskDescription: z.string(),\n      currentState: z.string(),\n      previousCode: z.string().optional(),\n    }),\n  },\n  output: {\n    schema: z.object({\n      nextState: z.string().describe('The next state in the FSM workflow.'),\n      agentAction: z.string().describe('The action to be performed by the agent.'),\n      generatedCode: z.string().describe('The code generated or modified in this step.'),\n      reasoning: z.string().describe('Explanation of the agent action and state transition.'),\n    }),\n  },\n  prompt: `You are a code bot operating within a finite state machine.\nYour task is to assist in generating code based on the user provided description, working one state at a time.\n\nYou are currently in state: {{{currentState}}}\nTask Description: {{{taskDescription}}}\n\nPrevious Code (if any):\n{{{previousCode}}}\n\nBased on the current state, determine the next appropriate state and the action to take. Ensure that each transition moves toward completion of the overall task.\n\nPossible states: Input, Draft, Correct, Validate, Done\n\nOutput the next state, the action, the generated code, and a reasoning for the next state transition.\n\nExample Output Format:\n{\n  \"nextState\": \"Draft\",\n  \"agentAction\": \"Generate initial code draft\",\n  \"generatedCode\": \"\",\n  \"reasoning\": \"Initial code generation required to begin the task.\"\n}\n`,\n});\n\nconst automatedWorkflowWithCodeBotFSMFlow = ai.defineFlow(\n  {\n    name: 'automatedWorkflowWithCodeBotFSMFlow',\n    inputSchema: AutomatedWorkflowWithCodeBotFSMInputSchema,\n    outputSchema: AutomatedWorkflowWithCodeBotFSMOutputSchema,\n  },\n  async input => {\n    let currentState = 'Input';\n    let generatedCode = '';\n    let workflowSummary = '';\n    let stepCount = 0;\n\n    while (currentState !== 'Done' && stepCount < 10) { // Limiting steps to avoid infinite loops\n      stepCount++;\n      const {output} = await prompt({\n        taskDescription: input.taskDescription,\n        currentState: currentState,\n        previousCode: generatedCode,\n      });\n\n      if (!output) {\n        throw new Error('Prompt returned no output.');\n      }\n\n      currentState = output.nextState;\n      generatedCode = output.generatedCode;\n      workflowSummary += `Step ${stepCount}: State=${output.nextState}, Action=${output.agentAction}, Reasoning=${output.reasoning}\\n`;\n    }\n\n    return {\n      generatedCode: generatedCode,\n      workflowSummary: workflowSummary,\n    };\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;CAQC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,6CAA6C,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1D,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACvC;AAGA,MAAM,8CAA8C,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3D,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACnC,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACvC;AAGO,eAAe,gCAAgC,KAA2C;IAC/F,OAAO,oCAAoC;AAC7C;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM;YACzB,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM;YACtB,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;QACnC;IACF;IACA,QAAQ;QACN,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;YAC/B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;YACjC,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;YACnC,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACjC;IACF;IACA,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;AAsBX,CAAC;AACD;AAEA,MAAM,sCAAsC,mHAAA,CAAA,KAAE,CAAC,UAAU,CACvD;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,IAAI,eAAe;IACnB,IAAI,gBAAgB;IACpB,IAAI,kBAAkB;IACtB,IAAI,YAAY;IAEhB,MAAO,iBAAiB,UAAU,YAAY,GAAI;QAChD;QACA,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;YAC5B,iBAAiB,MAAM,eAAe;YACtC,cAAc;YACd,cAAc;QAChB;QAEA,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MAAM;QAClB;QAEA,eAAe,OAAO,SAAS;QAC/B,gBAAgB,OAAO,aAAa;QACpC,mBAAmB,CAAC,KAAK,EAAE,UAAU,QAAQ,EAAE,OAAO,SAAS,CAAC,SAAS,EAAE,OAAO,WAAW,CAAC,YAAY,EAAE,OAAO,SAAS,CAAC,EAAE,CAAC;IAClI;IAEA,OAAO;QACL,eAAe;QACf,iBAAiB;IACnB;AACF;;;IA/EoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 403, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/lucide-icon-validator.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview An AI agent that validates lucide-react icon imports in a code snippet.\n * This FSM-based agent first performs deterministic checks (parsing imports and validating against a known list)\n * and only delegates the fuzzy task of suggesting alternatives to an LLM, perfectly demonstrating the\n * aGi²TEAM³FSMbot¹ principle of using FSMs for structured work.\n *\n * - lucidIconValidator - A function that handles the icon validation process.\n * - LucidIconValidatorInput - The input type for the lucidIconValidator function.\n * - LucidIconValidatorOutput - The return type for the lucidIconValidator function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport * as allIcons from 'lucide-react';\n\nconst LucidIconValidatorInputSchema = z.object({\n  code: z.string().describe('The code snippet to validate for lucide-react icons.'),\n});\nexport type LucidIconValidatorInput = z.infer<typeof LucidIconValidatorInputSchema>;\n\nconst LucidIconValidatorOutputSchema = z.object({\n  validIcons: z.array(z.string()).describe('A list of valid lucide-react icons found in the code.'),\n  invalidIcons: z.array(z.string()).describe('A list of invalid lucide-react icons found in the code.'),\n  recommendations: z.record(z.string(), z.string()).describe('A map of invalid icons to suggested valid alternatives.'),\n});\nexport type LucidIconValidatorOutput = z.infer<typeof LucidIconValidatorOutputSchema>;\n\nexport async function lucidIconValidator(input: LucidIconValidatorInput): Promise<LucidIconValidatorOutput> {\n  return lucidIconValidatorFlow(input);\n}\n\n// FSM-like logic for validation, implemented within a flow.\nconst lucidIconValidatorFlow = ai.defineFlow(\n  {\n    name: 'lucidIconValidatorFlow',\n    inputSchema: LucidIconValidatorInputSchema,\n    outputSchema: LucidIconValidatorOutputSchema,\n  },\n  async ({ code }) => {\n    // State: PARSE_IMPORTS\n    const importRegex = /import\\s+{([^}]+)}\\s+from\\s+['\"]lucide-react['\"]/g;\n    const allImportedIcons: string[] = [];\n    let match;\n    while ((match = importRegex.exec(code)) !== null) {\n      const icons = match[1].split(',').map(name => name.trim()).filter(name => name && !name.includes(' '));\n      allImportedIcons.push(...icons);\n    }\n\n    if (allImportedIcons.length === 0) {\n      return { validIcons: [], invalidIcons: [], recommendations: {} };\n    }\n    \n    const validIconSet = new Set(Object.keys(allIcons));\n    \n    // State: VALIDATE_ICONS\n    const validIcons: string[] = [];\n    const invalidIcons: string[] = [];\n\n    for (const icon of allImportedIcons) {\n      if (validIconSet.has(icon)) {\n        validIcons.push(icon);\n      } else {\n        invalidIcons.push(icon);\n      }\n    }\n\n    if (invalidIcons.length === 0) {\n      return { validIcons, invalidIcons: [], recommendations: {} };\n    }\n\n    // State: GENERATE_RECOMMENDATIONS (using an LLM for fuzzy matching)\n    const { output } = await ai.generate({\n      prompt: `Given a list of invalid lucide-react icon names, suggest valid alternatives from the official list. For each invalid icon, suggest the closest valid icon name.\n\nInvalid Icons: ${invalidIcons.join(', ')}\nValid Icons list (sample): FolderTree, Folder, File, FileCode, Bot, ShieldCheck\n\nReturn a JSON object mapping the invalid icon to its recommended replacement. For example: { \"FileTreee\": \"FolderTree\", \"ClipbordCheck\": \"ClipboardCheck\" }. If no good alternative exists, suggest a reasonable replacement like 'HelpCircle'.`,\n      format: 'json',\n    });\n    \n    const recommendations = output ?? {};\n\n    return { validIcons, invalidIcons, recommendations };\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;;;;CASC,GAED;AACA;AAAA;AACA;;;;;;;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC5B;AAGA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,YAAY,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACzC,cAAc,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IAC3C,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;AAC7D;AAGO,eAAe,mBAAmB,KAA8B;IACrE,OAAO,uBAAuB;AAChC;AAEA,4DAA4D;AAC5D,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO,EAAE,IAAI,EAAE;IACb,uBAAuB;IACvB,MAAM,cAAc;IACpB,MAAM,mBAA6B,EAAE;IACrC,IAAI;IACJ,MAAO,CAAC,QAAQ,YAAY,IAAI,CAAC,KAAK,MAAM,KAAM;QAChD,MAAM,QAAQ,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA,OAAQ,KAAK,IAAI,IAAI,MAAM,CAAC,CAAA,OAAQ,QAAQ,CAAC,KAAK,QAAQ,CAAC;QACjG,iBAAiB,IAAI,IAAI;IAC3B;IAEA,IAAI,iBAAiB,MAAM,KAAK,GAAG;QACjC,OAAO;YAAE,YAAY,EAAE;YAAE,cAAc,EAAE;YAAE,iBAAiB,CAAC;QAAE;IACjE;IAEA,MAAM,eAAe,IAAI,IAAI,OAAO,IAAI,CAAC;IAEzC,wBAAwB;IACxB,MAAM,aAAuB,EAAE;IAC/B,MAAM,eAAyB,EAAE;IAEjC,KAAK,MAAM,QAAQ,iBAAkB;QACnC,IAAI,aAAa,GAAG,CAAC,OAAO;YAC1B,WAAW,IAAI,CAAC;QAClB,OAAO;YACL,aAAa,IAAI,CAAC;QACpB;IACF;IAEA,IAAI,aAAa,MAAM,KAAK,GAAG;QAC7B,OAAO;YAAE;YAAY,cAAc,EAAE;YAAE,iBAAiB,CAAC;QAAE;IAC7D;IAEA,oEAAoE;IACpE,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,mHAAA,CAAA,KAAE,CAAC,QAAQ,CAAC;QACnC,QAAQ,CAAC;;eAEA,EAAE,aAAa,IAAI,CAAC,MAAM;;;+OAGsM,CAAC;QAC1O,QAAQ;IACV;IAEA,MAAM,kBAAkB,UAAU,CAAC;IAEnC,OAAO;QAAE;QAAY;QAAc;IAAgB;AACrD;;;IAzDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 505, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/policy-parsing-fsm.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview A Policy parsing AI agent implemented as a Finite State Machine (FSM). This agent\n * is designed to deterministically parse and validate structured data formats like YAML,\n * ensuring that policies are well-formed before they are used to direct other AI agents.\n *\n * - parsePolicyWithFSM - A function that parses Policy input using an FSM.\n * - PolicyParsingFSMInput - The input type for the parsePolicyWithFSM function.\n * - PolicyParsingFSMOutput - The return type for the parsePolicyWithFSM function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\nimport yaml from 'js-yaml';\n\nconst PolicyParsingFSMInputSchema = z\n  .string()\n  .describe('The Policy input to be parsed.');\n\nexport type PolicyParsingFSMInput = z.infer<typeof PolicyParsingFSMInputSchema>;\n\nconst PolicyParsingFSMOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the Policy is valid according to the FSM.'),\n  parsedPolicy: z.record(z.string(), z.any()).optional().describe('The parsed Policy object if valid, otherwise undefined.'),\n  errorMessage: z.string().optional().describe('An error message if the Policy is invalid.'),\n});\n\nexport type PolicyParsingFSMOutput = z.infer<typeof PolicyParsingFSMOutputSchema>;\n\nexport async function parsePolicyWithFSM(input: PolicyParsingFSMInput): Promise<PolicyParsingFSMOutput> {\n  return policyParsingFSMFlow(input);\n}\n\nconst policyParsingFSMFlow = ai.defineFlow(\n  {\n    name: 'policyParsingFSMFlow',\n    inputSchema: PolicyParsingFSMInputSchema,\n    outputSchema: PolicyParsingFSMOutputSchema,\n  },\n  async input => {\n    // FSM States: START -> PARSING -> VALIDATING -> DONE/ERROR\n    let state = 'START';\n    try {\n      state = 'PARSING';\n      const parsedPolicy = yaml.load(input);\n\n      state = 'VALIDATING';\n      if (typeof parsedPolicy !== 'object' || parsedPolicy === null) {\n        throw new Error('YAML does not represent a valid object.');\n      }\n      \n      // Add more validation logic here if needed, e.g., schema validation.\n      // For now, we just check if it's a non-null object.\n\n      state = 'DONE';\n      return {\n        isValid: true,\n        parsedPolicy: parsedPolicy as Record<string, any>,\n      };\n    } catch (e: any) {\n      state = 'ERROR';\n      return {\n        isValid: false,\n        errorMessage: `Parsing failed in state ${state}: ${e.message}`,\n      };\n    }\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;;;CAQC,GAED;AACA;AAAA;AACA;;;;;;;AAEA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAClC,MAAM,GACN,QAAQ,CAAC;AAIZ,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5C,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,uIAAA,CAAA,IAAC,CAAC,GAAG,IAAI,QAAQ,GAAG,QAAQ,CAAC;IAChE,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAC/C;AAIO,eAAe,mBAAmB,KAA4B;IACnE,OAAO,qBAAqB;AAC9B;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACxC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,2DAA2D;IAC3D,IAAI,QAAQ;IACZ,IAAI;QACF,QAAQ;QACR,MAAM,eAAe,iJAAA,CAAA,UAAI,CAAC,IAAI,CAAC;QAE/B,QAAQ;QACR,IAAI,OAAO,iBAAiB,YAAY,iBAAiB,MAAM;YAC7D,MAAM,IAAI,MAAM;QAClB;QAEA,qEAAqE;QACrE,oDAAoD;QAEpD,QAAQ;QACR,OAAO;YACL,SAAS;YACT,cAAc;QAChB;IACF,EAAE,OAAO,GAAQ;QACf,QAAQ;QACR,OAAO;YACL,SAAS;YACT,cAAc,CAAC,wBAAwB,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE;QAChE;IACF;AACF;;;IArCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/code-state-validation.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview Code State Validation AI agent. This FSM-based agent validates a code snippet against a given state machine definition,\n * ensuring that the code adheres to the specified state transitions and logic. It's a core component for ensuring compliance\n * and predictability in an agentic coding ecosystem.\n *\n * - codeStateValidation - A function that handles the code state validation process.\n * - CodeStateValidationInput - The input type for the codeStateValidation function.\n * - CodeStateValidationOutput - The return type for the codeStateValidation function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst CodeStateValidationInputSchema = z.object({\n  code: z.string().describe('The code to validate.'),\n  fsmDefinition: z\n    .string() // Assuming FSM definition is passed as a string, could be JSON or other format\n    .describe('The FSM definition in a suitable format (e.g., JSON).'),\n});\nexport type CodeStateValidationInput = z.infer<typeof CodeStateValidationInputSchema>;\n\nconst CodeStateValidationOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the code is valid according to the FSM.'),\n  validationResult: z\n    .string()\n    .describe('A description of the validation result, including any errors found.'),\n});\nexport type CodeStateValidationOutput = z.infer<typeof CodeStateValidationOutputSchema>;\n\nexport async function codeStateValidation(input: CodeStateValidationInput): Promise<CodeStateValidationOutput> {\n  return codeStateValidationFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'codeStateValidationPrompt',\n  input: {schema: CodeStateValidationInputSchema},\n  output: {schema: CodeStateValidationOutputSchema},\n  prompt: `You are a code validation expert. You will receive a code snippet and an FSM definition. Your task is to determine if the code follows the state transitions defined in the FSM and is structurally sound according to it.\n\nCode:\n\n\\`\\`\\`{{{code}}}\n\\`\\`\\`\n\nFSM Definition:\n\n{{{fsmDefinition}}}\n\nBased on this, determine if the code is valid, and provide a detailed validation result.  Include specific details on which states it follows and which it violates. Set the \nisValid output field appropriately.`,\n});\n\nconst codeStateValidationFlow = ai.defineFlow(\n  {\n    name: 'codeStateValidationFlow',\n    inputSchema: CodeStateValidationInputSchema,\n    outputSchema: CodeStateValidationOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;;;CAQC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,eAAe,uIAAA,CAAA,IAAC,CACb,MAAM,GAAG,+EAA+E;KACxF,QAAQ,CAAC;AACd;AAGA,MAAM,kCAAkC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,kBAAkB,uIAAA,CAAA,IAAC,CAChB,MAAM,GACN,QAAQ,CAAC;AACd;AAGO,eAAe,oBAAoB,KAA+B;IACvE,OAAO,wBAAwB;AACjC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA8B;IAC9C,QAAQ;QAAC,QAAQ;IAA+B;IAChD,QAAQ,CAAC;;;;;;;;;;;;mCAYwB,CAAC;AACpC;AAEA,MAAM,0BAA0B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC3C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAhCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 651, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["'use server';\n\nimport {\n  automatedWorkflowWithCodeBotFSM,\n  type AutomatedWorkflowWithCodeBotFSMInput,\n} from '@/ai/flows/automated-workflow-with-code-bot-fsm';\nimport {\n  lucidIconValidator,\n  type LucidIconValidatorInput,\n} from '@/ai/flows/lucide-icon-validator';\nimport {\n  parsePolicyWithFSM,\n  type PolicyParsingFSMInput,\n} from '@/ai/flows/policy-parsing-fsm';\nimport {\n  codeStateValidation,\n  type CodeStateValidationInput,\n} from '@/ai/flows/code-state-validation';\n\nexport async function runCodeBotWorkflowAction(\n  input: AutomatedWorkflowWithCodeBotFSMInput\n) {\n  try {\n    const result = await automatedWorkflowWithCodeBotFSM(input);\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: (error as Error).message };\n  }\n}\n\nexport async function validateIconsAction(input: LucidIconValidatorInput) {\n  try {\n    const result = await lucidIconValidator(input);\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: (error as Error).message };\n  }\n}\n\nexport async function parsePolicyAction(input: PolicyParsingFSMInput) {\n  try {\n    const result = await parsePolicyWithFSM(input);\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: (error as Error).message };\n  }\n}\n\nexport async function validateCodeStateAction(\n  input: CodeStateValidationInput\n) {\n  try {\n    const result = await codeStateValidation(input);\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: (error as Error).message };\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;AAIA;AAIA;AAIA;;;;;;;;AAKO,eAAe,yBACpB,KAA2C;IAE3C,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,yKAAA,CAAA,kCAA+B,AAAD,EAAE;QACrD,OAAO;YAAE,SAAS;YAAM,MAAM;QAAO;IACvC,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;YAAO,OAAO,AAAC,MAAgB,OAAO;QAAC;IAC3D;AACF;AAEO,eAAe,oBAAoB,KAA8B;IACtE,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,iJAAA,CAAA,qBAAkB,AAAD,EAAE;QACxC,OAAO;YAAE,SAAS;YAAM,MAAM;QAAO;IACvC,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;YAAO,OAAO,AAAC,MAAgB,OAAO;QAAC;IAC3D;AACF;AAEO,eAAe,kBAAkB,KAA4B;IAClE,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,8IAAA,CAAA,qBAAkB,AAAD,EAAE;QACxC,OAAO;YAAE,SAAS;YAAM,MAAM;QAAO;IACvC,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;YAAO,OAAO,AAAC,MAAgB,OAAO;QAAC;IAC3D;AACF;AAEO,eAAe,wBACpB,KAA+B;IAE/B,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,iJAAA,CAAA,sBAAmB,AAAD,EAAE;QACzC,OAAO;YAAE,SAAS;YAAM,MAAM;QAAO;IACvC,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;YAAO,OAAO,AAAC,MAAgB,OAAO;QAAC;IAC3D;AACF;;;IAtCsB;IAWA;IASA;IASA;;AA7BA,+OAAA;AAWA,+OAAA;AASA,+OAAA;AASA,+OAAA","debugId":null}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {parsePolicyAction as '40a9953b733a01dcfbac62e1e0d05ddda43307a95a'} from 'ACTIONS_MODULE0'\nexport {validateIconsAction as '4022505cd09e22f855e70034109a58fd1758ab33e2'} from 'ACTIONS_MODULE0'\nexport {validateCodeStateAction as '406896be9584f52224120cbcf3024826a1154ac4dc'} from 'ACTIONS_MODULE0'\nexport {runCodeBotWorkflowAction as '40ae6912e6f916bcf83e16b2cbeb5019aef8c8137a'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 804, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}