{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/common/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z } from 'genkit';\n\n/** Function calling mode. */\nexport enum FunctionCallingMode {\n  /** Unspecified function calling mode. This value should not be used. */\n  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED',\n  /**\n   * Default model behavior, model decides to predict either function calls\n   * or natural language response.\n   */\n  AUTO = 'AUTO',\n  /**\n   * Model is constrained to always predicting function calls only.\n   * If \"allowedFunctionNames\" are set, the predicted function calls will be\n   * limited to any one of \"allowedFunctionNames\", else the predicted\n   * function calls will be any one of the provided \"function_declarations\".\n   */\n  ANY = 'ANY',\n  /**\n   * Model will not predict any function calls. Model behavior is same as when\n   * not passing any function declarations.\n   */\n  NONE = 'NONE',\n}\n\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * The reason why the response is blocked.\n */\nexport enum BlockReason {\n  /** Unspecified block reason. */\n  BLOCKED_REASON_UNSPECIFIED = 'BLOCKED_REASON_UNSPECIFIED', // GoogleAI\n  BLOCK_REASON_UNSPECIFIED = 'BLOCK_REASON_UNSPECIFIED', // VertexAI\n\n  /** Candidates blocked due to safety. */\n  SAFETY = 'SAFETY',\n  /** Candidates blocked due to other reason. */\n  OTHER = 'OTHER',\n  /** terminology blocklist. */\n  BLOCKLIST = 'BLOCKLIST',\n  /** Candidates blocked due to prohibited content. */\n  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT',\n}\n\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nexport enum HarmCategory {\n  HARM_CATEGORY_UNSPECIFIED = 'HARM_CATEGORY_UNSPECIFIED',\n  HARM_CATEGORY_HATE_SPEECH = 'HARM_CATEGORY_HATE_SPEECH',\n  HARM_CATEGORY_SEXUALLY_EXPLICIT = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HARM_CATEGORY_HARASSMENT = 'HARM_CATEGORY_HARASSMENT',\n  HARM_CATEGORY_DANGEROUS_CONTENT = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n  HARM_CATEGORY_CIVIC_INTEGRITY = 'HARM_CATEGORY_CIVIC_INTEGRITY',\n}\n\n/**\n * Probability based thresholds levels for blocking.\n */\nexport enum HarmBlockThreshold {\n  /** Unspecified harm block threshold. */\n  HARM_BLOCK_THRESHOLD_UNSPECIFIED = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n  /** Block low threshold and above (i.e. block more). */\n  BLOCK_LOW_AND_ABOVE = 'BLOCK_LOW_AND_ABOVE',\n  /** Block medium threshold and above. */\n  BLOCK_MEDIUM_AND_ABOVE = 'BLOCK_MEDIUM_AND_ABOVE',\n  /** Block only high threshold (i.e. block less). */\n  BLOCK_ONLY_HIGH = 'BLOCK_ONLY_HIGH',\n  /** Block none. */\n  BLOCK_NONE = 'BLOCK_NONE',\n  /** Turn off the safety filter. */\n  OFF = 'OFF',\n}\n\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nexport enum HarmProbability {\n  /** Probability is unspecified. */\n  HARM_PROBABILITY_UNSPECIFIED = 'HARM_PROBABILITY_UNSPECIFIED',\n  /** Content has a negligible chance of being unsafe. */\n  NEGLIGIBLE = 'NEGLIGIBLE',\n  /** Content has a low chance of being unsafe. */\n  LOW = 'LOW',\n  /** Content has a medium chance of being unsafe. */\n  MEDIUM = 'MEDIUM',\n  /** Content has a high chance of being unsafe. */\n  HIGH = 'HIGH',\n}\n\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nexport enum DynamicRetrievalMode {\n  // Unspecified function calling mode. This value should not be used.\n  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED',\n  // Run retrieval only when system decides it is necessary.\n  MODE_DYNAMIC = 'MODE_DYNAMIC',\n}\n\n/**\n * Specifies the dynamic retrieval configuration for the given source.\n * @public\n */\nexport declare interface DynamicRetrievalConfig {\n  /**\n   * The mode of the predictor to be used in dynamic retrieval.\n   */\n  mode?: DynamicRetrievalMode;\n  /**\n   * The threshold to be used in dynamic retrieval. If not set, a system default\n   * value is used.\n   */\n  dynamicThreshold?: number;\n}\n\n/**\n * Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface GoogleSearchRetrievalTool {\n  /** Optional. {@link GoogleSearchRetrieval}. */\n  googleSearchRetrieval?: GoogleSearchRetrieval;\n  googleSearch?: GoogleSearchRetrieval;\n}\nexport function isGoogleSearchRetrievalTool(\n  tool: Tool\n): tool is GoogleSearchRetrievalTool {\n  return (\n    (tool as GoogleSearchRetrievalTool).googleSearchRetrieval !== undefined ||\n    (tool as GoogleSearchRetrievalTool).googleSearch !== undefined\n  );\n}\n\n/**\n * Grounding support.\n */\nexport declare interface GroundingSupport {\n  /** Optional. Segment of the content this support belongs to. */\n  segment?: GroundingSupportSegment;\n  /**\n   * Optional. A array of indices (into {@link GroundingChunk}) specifying the\n   * citations associated with the claim. For instance [1,3,4] means\n   * that grounding_chunk[1], grounding_chunk[3],\n   * grounding_chunk[4] are the retrieved content attributed to the claim.\n   */\n  groundingChunkIndices?: number[];\n  /**\n   * Confidence score of the support references. Ranges from 0 to 1. 1 is the\n   * most confident. This list must have the same size as the\n   * groundingChunkIndices.\n   */\n  confidenceScores?: number[];\n}\n\n/**\n * Grounding support segment.\n */\nexport declare interface GroundingSupportSegment {\n  /** Optional. The index of a Part object within its parent Content object. */\n  partIndex?: number;\n  /**\n   * Optional. Start index in the given Part, measured in bytes.\n   * Offset from the start of the Part, inclusive, starting at zero.\n   */\n  startIndex?: number;\n  /**\n   * Optional. End index in the given Part, measured in bytes.\n   * Offset from the start of the Part, exclusive, starting at zero.\n   */\n  endIndex?: number;\n  /** Optional. The text corresponding to the segment from the response. */\n  text?: string;\n}\n\n/**\n * Harm severity levels\n */\nexport enum HarmSeverity {\n  /** Harm severity unspecified. */\n  HARM_SEVERITY_UNSPECIFIED = 'HARM_SEVERITY_UNSPECIFIED',\n  /** Negligible level of harm severity. */\n  HARM_SEVERITY_NEGLIGIBLE = 'HARM_SEVERITY_NEGLIGIBLE',\n  /** Low level of harm severity. */\n  HARM_SEVERITY_LOW = 'HARM_SEVERITY_LOW',\n  /** Medium level of harm severity. */\n  HARM_SEVERITY_MEDIUM = 'HARM_SEVERITY_MEDIUM',\n  /** High level of harm severity. */\n  HARM_SEVERITY_HIGH = 'HARM_SEVERITY_HIGH',\n}\n\n/**\n * Safety rating corresponding to the generated content.\n */\nexport declare interface SafetyRating {\n  /** The harm category. {@link HarmCategory} */\n  category?: HarmCategory;\n  /** The harm probability. {@link HarmProbability} */\n  probability?: HarmProbability;\n  /** The harm probability score. */\n  probabilityScore?: number;\n  /** The harm severity.level {@link HarmSeverity} */\n  severity?: HarmSeverity;\n  /** The harm severity score. */\n  severityScore?: number;\n}\n\n/**\n * If the prompt was blocked, this will be populated with `blockReason` and\n * the relevant `safetyRatings`.\n */\nexport declare interface PromptFeedback {\n  /** The reason why the response is blocked. {@link BlockReason}. */\n  blockReason: BlockReason;\n  /** Array of {@link SafetyRating} */\n  safetyRatings: SafetyRating[];\n  /** A readable block reason message. */\n  blockReasonMessage?: string;\n}\n\n/**\n * URI based data.\n */\nexport declare interface FileData {\n  /** The IANA standard MIME type of the source data. */\n  mimeType: string;\n  /** URI of the file. */\n  fileUri: string;\n}\n\n/**\n * Raw media bytes sent directly in the request. Text should not be sent as\n * raw bytes.\n */\nexport declare interface GenerativeContentBlob {\n  /**\n   * The MIME type of the source data. The only accepted values: \"image/png\" or\n   * \"image/jpeg\".\n   */\n  mimeType: string;\n  /** Base64 encoded data. */\n  data: string;\n}\n\n/**\n * A predicted FunctionCall returned from the model that contains a string\n * representating the FunctionDeclaration.name with the parameters and their\n * values.\n */\nexport declare interface FunctionCall {\n  /** The name of the function specified in FunctionDeclaration.name. */\n  name: string;\n  /** The arguments to pass to the function. */\n  args: object;\n}\n\n/**\n * The result output of a FunctionCall that contains a string representing\n * the FunctionDeclaration.name and a structured JSON object containing any\n * output from the function call. It is used as context to the model.\n */\nexport declare interface FunctionResponse {\n  /** The name of the function specified in FunctionDeclaration.name. */\n  name: string;\n  /** The expected response from the model. */\n  response: object;\n}\n\n/**\n * The list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n */\nexport enum SchemaType {\n  /** String type. */\n  STRING = 'STRING',\n  /** Number type. */\n  NUMBER = 'NUMBER',\n  /** Integer type. */\n  INTEGER = 'INTEGER',\n  /** Boolean type. */\n  BOOLEAN = 'BOOLEAN',\n  /** Array type. */\n  ARRAY = 'ARRAY',\n  /** Object type. */\n  OBJECT = 'OBJECT',\n}\n\nexport declare interface Schema {\n  type?: SchemaType;\n  format?: string;\n  title?: string;\n  description?: string;\n  nullable?: boolean;\n  items?: Schema;\n  minItems?: number;\n  maxItems?: number;\n  properties?: Record<string, Schema>;\n  enum?: string[];\n  required?: string[];\n  example?: unknown;\n}\n\n/**\n * Schema for parameters passed to {@link FunctionDeclaration.parameters}.\n */\nexport declare interface FunctionDeclarationSchema {\n  /** The type of the parameter. */\n  type: SchemaType;\n  /** The format of the parameter. */\n  properties: Record<string, Schema>;\n  /** Optional. Description of the parameter. */\n  description?: string;\n  /** Optional. Array of required parameters. */\n  required?: string[];\n}\n\nexport declare interface FunctionDeclaration {\n  /**\n   * The name of the function to call. Must start with a letter or an\n   * underscore. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with\n   * a max length of 64.\n   */\n  name: string;\n  /**\n   * Optional. Description and purpose of the function. Model uses it to decide\n   * how and whether to call the function.\n   */\n  description?: string;\n  /**\n   * Optional. Describes the parameters to this function in JSON Schema Object\n   * format. Reflects the Open API 3.03 Parameter Object. string Key: the name\n   * of the parameter. Parameter names are case sensitive. Schema Value: the\n   * Schema defining the type used for the parameter. For function with no\n   * parameters, this can be left unset.\n   *\n   * @example with 1 required and 1 optional parameter: type: OBJECT properties:\n   * ```\n   * param1:\n   *\n   *   type: STRING\n   * param2:\n   *\n   *  type: INTEGER\n   * required:\n   *\n   *   - param1\n   * ```\n   */\n  parameters?: FunctionDeclarationSchema;\n}\n\n/**\n * Metadata on the generation request's token usage.\n */\nexport declare interface UsageMetadata {\n  /** Optional. Number of tokens in the request. */\n  promptTokenCount?: number;\n  /** Optional. Number of tokens in the response(s). */\n  candidatesTokenCount?: number;\n  /** Optional. Total number of tokens. */\n  totalTokenCount?: number;\n  /** Optional. Number of tokens in the cached content. */\n  cachedContentTokenCount?: number;\n  /** Optional. Number of tokens present in thoughts output. */\n  thoughtsTokenCount?: number;\n}\n\nexport const TaskTypeSchema = z.enum([\n  'RETRIEVAL_DOCUMENT',\n  'RETRIEVAL_QUERY',\n  'SEMANTIC_SIMILARITY',\n  'CLASSIFICATION',\n  'CLUSTERING',\n]);\n\nexport type TaskType = z.infer<typeof TaskTypeSchema>;\n\n/**\n * Reason that a candidate finished.\n * @public\n */\nexport enum FinishReason {\n  // Default value. This value is unused.\n  FINISH_REASON_UNSPECIFIED = 'FINISH_REASON_UNSPECIFIED',\n  // Natural stop point of the model or provided stop sequence.\n  STOP = 'STOP',\n  // The maximum number of tokens as specified in the request was reached.\n  MAX_TOKENS = 'MAX_TOKENS',\n  // The candidate content was flagged for safety reasons.\n  SAFETY = 'SAFETY',\n  // The candidate content was flagged for recitation reasons.\n  RECITATION = 'RECITATION',\n  // The candidate content was flagged for using an unsupported language.\n  LANGUAGE = 'LANGUAGE',\n  // Token generation stopped because the content contains forbidden terms.\n  BLOCKLIST = 'BLOCKLIST',\n  // Token generation stopped for potentially containing prohibited content.\n  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT',\n  // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n  SPII = 'SPII',\n  // The function call generated by the model is invalid.\n  MALFORMED_FUNCTION_CALL = 'MALFORMED_FUNCTION_CALL',\n  // Unknown reason.\n  OTHER = 'OTHER',\n}\n\n/**\n * Represents a whole or partial calendar date, such as a birthday. The time of\n * day and time zone are either specified elsewhere or are insignificant. The\n * date is relative to the Gregorian Calendar. This can represent one of the\n * following:\n *\n *   A full date, with non-zero year, month, and day values.\n *   A month and day, with a zero year (for example, an anniversary).\n *   A year on its own, with a zero month and a zero day.\n *   A year and month, with a zero day (for example, a credit card expiration\n *   date).\n */\nexport declare interface GoogleDate {\n  /**\n   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a\n   * year.\n   */\n  year?: number;\n  /**\n   * Month of the date. Must be from 1 to 12, or 0 to specify a year without a\n   * month and day.\n   */\n  month?: number;\n  /**\n   * Day of the date. Must be from 1 to 31 and valid for the year and month.\n   * or 0 to specify a year by itself or a year and month where the day isn't\n   * significant\n   */\n  day?: number;\n}\n\n/**\n * Source attributions for content.\n */\nexport declare interface CitationSource {\n  /** Optional. Start index into the content. */\n  startIndex?: number;\n  /** Optional. End index into the content. */\n  endIndex?: number;\n  /** Optional. Url reference of the attribution. */\n  uri?: string;\n  /** Optional. License of the attribution. */\n  license?: string;\n  /** Optional. Title of the attribution. VertexAI only.*/\n  title?: string;\n  /** Optional. Publication date of the attribution. VertexAI only */\n  publicationDate?: GoogleDate;\n}\n\n/**\n * A collection of source attributions for a piece of content.\n */\nexport declare interface CitationMetadata {\n  /** Array of {@link CitationSource}. */\n  citations?: CitationSource[]; // VertexAI\n  citationSources?: CitationSource[]; // GoogleAI\n}\n\n/**\n * Google search entry point.\n */\nexport declare interface SearchEntryPoint {\n  /**\n   * Optional. Web content snippet that can be embedded in a web page or an app\n   * webview.\n   */\n  renderedContent?: string;\n  /** Optional. Base64 encoded JSON representing array of tuple. */\n  sdkBlob?: string;\n}\n\n/**\n * Grounding chunk from the web.\n */\nexport declare interface GroundingChunkWeb {\n  /** Optional. URI reference of the grounding chunk. */\n  uri?: string;\n  /** Optional. Title of the grounding chunk. */\n  title?: string;\n}\n\n/**\n * Grounding chunk from context retrieved by the retrieval tools.\n */\nexport declare interface GroundingChunkRetrievedContext {\n  /** Optional. URI reference of the attribution. */\n  uri?: string;\n  /** Optional. Title of the attribution. */\n  title?: string;\n}\n\n/**\n * Grounding chunk.\n */\nexport declare interface GroundingChunk {\n  /** Optional. Grounding chunk from the web. */\n  web?: GroundingChunkWeb;\n  /**\n   * Optional. Grounding chunk from context retrieved by the retrieval tools. (VertexAI only)\n   */\n  retrievedContext?: GroundingChunkRetrievedContext;\n}\n\n/**\n * Metadata related to retrieval in the grounding flow. GoogleAI only.\n * @public\n */\nexport declare interface RetrievalMetadata {\n  /**\n   * Score indicating how likely information from google search could help\n   * answer the prompt. The score is in the range [0, 1], where 0 is the least\n   * likely and 1 is the most likely. This score is only populated when google\n   * search grounding and dynamic retrieval is enabled. It will becompared to\n   * the threshold to determine whether to trigger google search.\n   */\n  googleSearchDynamicRetrievalScore?: number;\n}\n\n/**\n * A collection of grounding attributions for a piece of content.\n */\nexport declare interface GroundingMetadata {\n  /** Optional. Google search entry for the following-up web searches. {@link SearchEntryPoint} */\n  searchEntryPoint?: SearchEntryPoint;\n  /**\n   * Optional. Array of supporting references retrieved from specified\n   * grounding source. {@link GroundingChunk}.\n   */\n  groundingChunks?: GroundingChunk[];\n  /** Optional. Array of grounding support. {@link GroundingSupport}. */\n  groundingSupports?: GroundingSupport[];\n  /** Optional. Web search queries for the following-up web search. */\n  webSearchQueries?: string[];\n  /** Optional. Queries executed by the retrieval tools. VertexAI only*/\n  retrievalQueries?: string[];\n  /**\n   * Optional. Metadata related to retrieval in the grounding flow. GoogleAI only.\n   */\n  retrievalMetadata?: RetrievalMetadata;\n}\n\n/**\n * @public\n */\nexport enum ExecutableCodeLanguage {\n  LANGUAGE_UNSPECIFIED = 'LANGUAGE_UNSPECIFIED',\n  PYTHON = 'PYTHON',\n}\n\n/**\n * Code generated by the model that is meant to be executed, where the result\n * is returned to the model.\n * Only generated when using the code execution tool, in which the code will\n * be automatically executed, and a corresponding `CodeExecutionResult` will\n * also be generated.\n *\n * @public\n */\nexport declare interface ExecutableCode {\n  /**\n   * Programming language of the `code`.\n   */\n  language: ExecutableCodeLanguage;\n  /**\n   * The code to be executed.\n   */\n  code: string;\n}\n\n/**\n * Possible outcomes of code execution.\n * @public\n */\nexport enum Outcome {\n  /**\n   * Unspecified status. This value should not be used.\n   */\n  OUTCOME_UNSPECIFIED = 'OUTCOME_UNSPECIFIED',\n  /**\n   * Code execution completed successfully.\n   */\n  OUTCOME_OK = 'OUTCOME_OK',\n  /**\n   * Code execution finished but with a failure. `stderr` should contain the\n   * reason.\n   */\n  OUTCOME_FAILED = 'OUTCOME_FAILED',\n  /**\n   * Code execution ran for too long, and was cancelled. There may or may not\n   * be a partial output present.\n   */\n  OUTCOME_DEADLINE_EXCEEDED = 'OUTCOME_DEADLINE_EXCEEDED',\n}\n\n/**\n * Result of executing the `ExecutableCode`.\n * Only generated when using code execution, and always follows a `Part`\n * containing the `ExecutableCode`.\n * @public\n */\nexport declare interface CodeExecutionResult {\n  /**\n   * Outcome of the code execution.\n   */\n  outcome: Outcome;\n  /**\n   * Contains stdout when code execution is successful, stderr or other\n   * description otherwise.\n   */\n  output: string;\n}\n\n/**\n * This is a Gemini Part. (Users never see this\n * structure, it is just built by the converters.)\n */\nexport declare interface Part {\n  text?: string;\n  inlineData?: GenerativeContentBlob;\n  functionCall?: FunctionCall;\n  functionResponse?: FunctionResponse;\n  fileData?: FileData;\n  thought?: boolean;\n  thoughtSignature?: string;\n  executableCode?: ExecutableCode;\n  codeExecutionResult?: CodeExecutionResult;\n}\n\n/**\n * The base structured datatype containing multi-part content of a message.\n */\nexport declare interface Content {\n  /** The producer of the content. */\n  role: string;\n  /** Array of {@link Part}. */\n  parts: Part[];\n}\n\n/**\n * Candidate for the logprobs token and score.\n * @public\n */\nexport declare interface LogprobsCandidate {\n  /** The candidate's token string value. */\n  token: string;\n  /** The candidate's token id value. */\n  tokenID: number;\n  /** The candidate's log probability. */\n  logProbability: number;\n}\n\n/**\n * Candidates with top log probabilities at each decoding step\n */\nexport declare interface TopCandidates {\n  /** Sorted by log probability in descending order. */\n  candidates: LogprobsCandidate[];\n}\n\n/**\n * Logprobs Result\n * @public\n */\nexport declare interface LogprobsResult {\n  /** Length = total number of decoding steps. */\n  topCandidates: TopCandidates[];\n  /**\n   * Length = total number of decoding steps.\n   * The chosen candidates may or may not be in topCandidates.\n   */\n  chosenCandidates: LogprobsCandidate[];\n}\n\n/**\n * A candidate returned as part of a GenerateContentResponse.\n * @public\n */\nexport declare interface GenerateContentCandidate {\n  index: number;\n  content: Content;\n  finishReason?: FinishReason;\n  finishMessage?: string;\n  safetyRatings?: SafetyRating[];\n  citationMetadata?: CitationMetadata;\n  /** Average log probability score of the candidate. GoogleAI only*/\n  avgLogprobs?: number;\n  /** Log-likelihood scores for the response tokens and top tokens. GoogleAI only*/\n  logprobsResult?: LogprobsResult;\n  /** Search grounding metadata. */\n  groundingMetadata?: GroundingMetadata;\n}\n\n/**\n * Individual response from generateContent and generateContentStream.\n * `generateContentStream()` will return one in each chunk until\n * the stream is done.\n * @public\n */\nexport declare interface GenerateContentResponse {\n  /** Candidate responses from the model. */\n  candidates?: GenerateContentCandidate[];\n  /** The prompt's feedback related to the content filters. */\n  promptFeedback?: PromptFeedback;\n  /** Metadata on the generation request's token usage. */\n  usageMetadata?: UsageMetadata;\n}\n\n/**\n * A FunctionDeclarationsTool is a piece of code that enables the system to\n * interact with external systems to perform an action, or set of actions,\n * outside of knowledge and scope of the model.\n * @public\n */\nexport declare interface FunctionDeclarationsTool {\n  /**\n   * Optional. One or more function declarations\n   * to be passed to the model along with the current user query. Model may\n   * decide to call a subset of these functions by populating\n   * [FunctionCall][content.part.functionCall] in the response. User should\n   * provide a [FunctionResponse][content.part.functionResponse] for each\n   * function call in the next turn. Based on the function responses, Model will\n   * generate the final response back to the user. Maximum 64 function\n   * declarations can be provided.\n   */\n  functionDeclarations?: FunctionDeclaration[];\n}\nexport function isFunctionDeclarationsTool(\n  tool: Tool\n): tool is FunctionDeclarationsTool {\n  return (tool as FunctionDeclarationsTool).functionDeclarations !== undefined;\n}\n\n/**\n * Google AI Only. Enables the model to execute code as part of generation.\n * @public\n */\nexport declare interface CodeExecutionTool {\n  /**\n   * Provide an empty object to enable code execution. This field may have\n   * subfields added in the future.\n   */\n  codeExecution: {};\n}\nexport function isCodeExecutionTool(tool: Tool): tool is CodeExecutionTool {\n  return (tool as CodeExecutionTool).codeExecution !== undefined;\n}\n\n/**\n * Vertex AI Only. Retrieve from Vertex AI Search datastore for grounding.\n */\nexport declare interface VertexAISearch {\n  /**\n   * Fully-qualified Vertex AI Search's datastore resource ID. See\n   * https://cloud.google.com/vertex-ai-search-and-conversation\n   *\n   * @example\n   * \"projects/<>/locations/<>/collections/<>/dataStores/<>\"\n   */\n  datastore: string;\n}\n\n/**\n * Vertex AI Only. Config of Vertex RagStore grounding checking.\n */\nexport declare interface RagResource {\n  /**\n   * Optional. Vertex RAG Store corpus resource name.\n   *\n   * @example\n   * `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`\n   */\n  ragCorpus?: string;\n\n  /**\n   * Optional. Set this field to select the files under the ragCorpora for\n   * retrieval.\n   */\n  ragFileIds?: string[];\n}\n\n/** Vertex AI Only. */\nexport declare interface VertexRagStore {\n  /**\n   * Optional. List of corpora for retrieval. Currently only support one corpus\n   * or multiple files from one corpus. In the future we may open up multiple\n   * corpora support.\n   */\n  ragResources?: RagResource[];\n\n  /** Optional. Number of top k results to return from the selected corpora. */\n  similarityTopK?: number;\n\n  /**\n   * Optional. If set this field, results with vector distance smaller than\n   * this threshold will be returned.\n   */\n  vectorDistanceThreshold?: number;\n}\n\n/**\n * Vertex AI Only. Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface Retrieval {\n  /**\n   * Optional. Set to use data source powered by Vertex AI Search. {@link\n   * VertexAISearch}.\n   */\n  vertexAiSearch?: VertexAISearch;\n\n  /** Optional. Set to use data source powered by Vertex RAG store. */\n  vertexRagStore?: VertexRagStore;\n\n  /**\n   * Optional. Disable using the result from this tool in detecting grounding\n   * attribution. This does not affect how the result is given to the model for\n   * generation.\n   */\n  disableAttribution?: boolean;\n}\n\n/**\n * Vertex AI Only. Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface RetrievalTool {\n  /** Optional. {@link Retrieval}. */\n  retrieval?: Retrieval;\n}\nexport function isRetrievalTool(tool: Tool): tool is RetrievalTool {\n  return (tool as RetrievalTool).retrieval !== undefined;\n}\n\n/**\n * Tool to retrieve public web data for grounding, powered by Google.\n */\nexport declare interface GoogleSearchRetrieval {\n  /** Specifies the dynamic retrieval configuration for the given source. */\n  dynamicRetrievalConfig?: DynamicRetrievalConfig;\n}\n\n/**\n * Defines a tool that model can call to access external knowledge.\n * @public\n */\nexport declare type Tool =\n  | FunctionDeclarationsTool\n  | RetrievalTool // Vertex AI Only\n  | CodeExecutionTool // Google AI Only\n  | GoogleSearchRetrievalTool;\n\n/**\n * Configuration options for model generation and outputs.\n */\nexport declare interface GenerationConfig {\n  /** Optional. If true, the timestamp of the audio will be included in the response. */\n  audioTimestamp?: boolean;\n  /** Optional. Number of candidates to generate. */\n  candidateCount?: number;\n  /** Optional. Stop sequences. */\n  stopSequences?: string[];\n  /** Optional. The maximum number of output tokens to generate per message. */\n  maxOutputTokens?: number;\n  /** Optional. Controls the randomness of predictions. */\n  temperature?: number;\n  /** Optional. If specified, nucleus sampling will be used. */\n  topP?: number;\n  /** Optional. If specified, topK sampling will be used. */\n  topK?: number;\n  /**\n   * Google AI only. Presence penalty applied to the next token's logprobs if the token has\n   * already been seen in the response.\n   */\n  presencePenalty?: number;\n  /**\n   * Optional. Positive values penalize tokens that repeatedly appear in the generated text, decreasing the probability of repeating content.\n   * This maximum value for frequencyPenalty is up to, but not including, 2.0. Its minimum value is -2.0.\n   * Supported by gemini-1.5-pro and gemini-1.5-flash only. */\n  frequencyPenalty?: number;\n  /**\n   * Google AI Only. If True, export the logprobs results in response.\n   */\n  responseLogprobs?: boolean;\n  /**\n   * Google AI Only. Valid if responseLogProbs is set to True. This will set the number of top\n   * logprobs to return at each decoding step in the logprobsResult.\n   */\n  logprobs?: number;\n  /**\n   * Optional. Output response mimetype of the generated candidate text.\n   * Supported mimetype:\n   * - `text/plain`: (default) Text output.\n   * - `application/json`: JSON response in the candidates.\n   * The model needs to be prompted to output the appropriate response type,\n   * otherwise the behavior is undefined.\n   */\n  responseMimeType?: string;\n\n  /**\n   * Optional. The schema that generated candidate text must follow.  For more\n   * information, see\n   * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/control-generated-output.\n   * If set, a compatible responseMimeType must also be set.\n   */\n  responseSchema?: Schema;\n}\n\n/**\n * Safety setting that can be sent as part of request parameters.\n * @public\n */\nexport declare interface SafetySetting {\n  category: HarmCategory;\n  threshold: HarmBlockThreshold;\n}\n\nexport declare interface FunctionCallingConfig {\n  /** Optional. Function calling mode. */\n  mode?: FunctionCallingMode;\n\n  /**\n   * Optional. Function names to call. Only set when the Mode is ANY. Function\n   * names should match [FunctionDeclaration.name]. With mode set to ANY, model\n   * will predict a function call from the set of function names provided.\n   */\n  allowedFunctionNames?: string[];\n}\n\n/** This config is shared for all tools provided in the request. */\nexport declare interface ToolConfig {\n  /** Function calling config. */\n  functionCallingConfig?: FunctionCallingConfig;\n}\n\nexport declare interface GenerateContentRequest {\n  /** Array of {@link Content}.*/\n  contents: Content[];\n  /**\n   * Optional. The name of the cached content used as context to serve the prediction.\n   * This is the name of a `CachedContent` and not the cache object itself.\n   */\n  cachedContent?: string;\n  /** Optional.  {@link GenerationConfig}. */\n  generationConfig?: GenerationConfig;\n  /**\n   * Optional. Vertex AI Only. Custom metadata labels for organizing API calls and managing costs at scale. See\n   * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls\n   */\n  labels?: Record<string, string>;\n  /** Optional. Array of {@link SafetySetting}. */\n  safetySettings?: SafetySetting[];\n  /**\n   * Optional. The user provided system instructions for the model.\n   * Note: only text should be used in parts of {@link Content}\n   */\n  systemInstruction?: string | Part | Content;\n  /** Optional. Array of {@link Tool}. */\n  tools?: Tool[];\n  /** Optional. This config is shared for all tools provided in the request. */\n  toolConfig?: ToolConfig;\n}\n\n/**\n * Result from calling generateContentStream.\n * It contains both the stream and the final aggregated response.\n * @public\n */\nexport declare interface GenerateContentStreamResult {\n  stream: AsyncGenerator<GenerateContentResponse>;\n  response: Promise<GenerateContentResponse>;\n}\n\nexport declare interface ImagenParameters {\n  sampleCount?: number;\n  aspectRatio?: string;\n  negativePrompt?: string; // Vertex only\n  seed?: number; // Vertex only\n  language?: string; // Vertex only\n  personGeneration?: string;\n  safetySetting?: string; // Vertex only\n  addWatermark?: boolean; // Vertex only\n  storageUri?: string; // Vertex only\n}\n\nexport declare interface ImagenPredictRequest {\n  instances: ImagenInstance[];\n  parameters: ImagenParameters;\n}\n\nexport declare interface ImagenPredictResponse {\n  predictions: ImagenPrediction[];\n}\n\nexport declare interface ImagenPrediction {\n  bytesBase64Encoded: string;\n  mimeType: string;\n}\n\nexport declare interface ImagenInstance {\n  prompt: string;\n  image?: { bytesBase64Encoded: string };\n  mask?: { image?: { bytesBase64Encoded: string } };\n}\n"],"names":["FunctionCallingMode","BlockReason","HarmCategory","HarmBlockThreshold","HarmProbability","DynamicRetrievalMode","HarmSeverity","SchemaType","FinishReason","ExecutableCodeLanguage","Outcome"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/common/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  EmbedderReference,\n  GenkitError,\n  Part as GenkitPart,\n  JSONSchema,\n  MediaPart,\n  ModelReference,\n  getClientHeader as defaultGetClientHeader,\n  z,\n} from 'genkit';\nimport { GenerateRequest } from 'genkit/model';\nimport {\n  GenerateContentCandidate,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  Part,\n  isObject,\n} from './types.js';\n\n/**\n * Safely extracts the error message from the error.\n * @param e The error\n * @returns The error message\n */\nexport function extractErrMsg(e: unknown): string {\n  let errorMessage = 'An unknown error occurred';\n  if (e instanceof Error) {\n    errorMessage = e.message;\n  } else if (typeof e === 'string') {\n    errorMessage = e;\n  } else {\n    // Fallback for other types\n    try {\n      errorMessage = JSON.stringify(e);\n    } catch (stringifyError) {\n      errorMessage = 'Failed to stringify error object';\n    }\n  }\n  return errorMessage;\n}\n\n/**\n * Gets the un-prefixed model name from a modelReference\n */\nexport function extractVersion(\n  model: ModelReference<z.ZodTypeAny> | EmbedderReference<z.ZodTypeAny>\n): string {\n  return model.version ? model.version : checkModelName(model.name);\n}\n\n/**\n * Gets the model name without certain prefixes..\n * e.g. for \"models/googleai/gemini-2.5-pro\" it returns just 'gemini-2.5-pro'\n * @param name A string containing the model string with possible prefixes\n * @returns the model string stripped of certain prefixes\n */\nexport function modelName(name?: string): string | undefined {\n  if (!name) return name;\n\n  // Remove any of these prefixes:\n  const prefixesToRemove =\n    /background-model\\/|model\\/|models\\/|embedders\\/|googleai\\/|vertexai\\//g;\n  return name.replace(prefixesToRemove, '');\n}\n\n/**\n * Gets the suffix of a model string.\n * Throws if the string is empty.\n * @param name A string containing the model string\n * @returns the model string stripped of prefixes and guaranteed not empty.\n */\nexport function checkModelName(name?: string): string {\n  const version = modelName(name);\n  if (!version) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: 'Model name is required.',\n    });\n  }\n  return version;\n}\n\nexport function extractText(request: GenerateRequest) {\n  return (\n    request.messages\n      .at(-1)\n      ?.content.map((c) => c.text || '')\n      .join('') ?? ''\n  );\n}\n\nconst KNOWN_MIME_TYPES = {\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n};\n\nexport function extractMimeType(url?: string): string {\n  if (!url) {\n    return '';\n  }\n\n  const dataPrefix = 'data:';\n  if (!url.startsWith(dataPrefix)) {\n    // Not a data url, try suffix\n    url.lastIndexOf('.');\n    const key = url.substring(url.lastIndexOf('.') + 1);\n    if (Object.keys(KNOWN_MIME_TYPES).includes(key)) {\n      return KNOWN_MIME_TYPES[key];\n    }\n    return '';\n  }\n\n  const commaIndex = url.indexOf(',');\n  if (commaIndex == -1) {\n    // Invalid - missing separator\n    return '';\n  }\n\n  // The part between 'data:' and the comma\n  let mimeType = url.substring(dataPrefix.length, commaIndex);\n  const base64Marker = ';base64';\n  if (mimeType.endsWith(base64Marker)) {\n    mimeType = mimeType.substring(0, mimeType.length - base64Marker.length);\n  }\n\n  return mimeType.trim();\n}\n\nexport function checkSupportedMimeType(\n  media: MediaPart['media'],\n  supportedTypes: string[]\n) {\n  if (!supportedTypes.includes(media.contentType ?? '')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: `Invalid mimeType for ${displayUrl(media.url)}: \"${media.contentType}\". Supported mimeTypes: ${supportedTypes.join(', ')}`,\n    });\n  }\n}\n\n/**\n *\n * @param url The url to show (e.g. in an error message)\n * @returns The appropriately  sized url\n */\nexport function displayUrl(url: string): string {\n  if (url.length <= 50) {\n    return url;\n  }\n\n  return url.substring(0, 25) + '...' + url.substring(url.length - 25);\n}\n\n/**\n *\n * @param request A generate request to extract from\n * @param metadataType The media must have metadata matching this type if isDefault is false\n * @param isDefault 'true' allows missing metadata type to match as well.\n * @returns\n */\nexport function extractMedia(\n  request: GenerateRequest,\n  params: {\n    metadataType?: string;\n    /* Is there is no metadata type, it will match if isDefault is true */\n    isDefault?: boolean;\n  }\n): MediaPart['media'] | undefined {\n  const predicate = (part: GenkitPart) => {\n    const media = part.media;\n    if (!media) {\n      return false;\n    }\n    if (params.metadataType || params.isDefault) {\n      // We need to check the metadata type\n      const metadata = part.metadata;\n      if (!metadata?.type) {\n        return !!params.isDefault;\n      } else {\n        return metadata.type == params.metadataType;\n      }\n    }\n    return true;\n  };\n\n  const media = request.messages.at(-1)?.content.find(predicate)?.media;\n\n  // Add the mimeType\n  if (media && !media?.contentType) {\n    return {\n      url: media.url,\n      contentType: extractMimeType(media.url),\n    };\n  }\n\n  return media;\n}\n\n/**\n * Cleans a JSON schema by removing specific keys and standardizing types.\n *\n * @param {JSONSchema} schema The JSON schema to clean.\n * @returns {JSONSchema} The cleaned JSON schema.\n */\nexport function cleanSchema(schema: JSONSchema): JSONSchema {\n  const out = structuredClone(schema);\n  for (const key in out) {\n    if (key === '$schema' || key === 'additionalProperties') {\n      delete out[key];\n      continue;\n    }\n    if (typeof out[key] === 'object') {\n      out[key] = cleanSchema(out[key]);\n    }\n    // Zod nullish() and picoschema optional fields will produce type `[\"string\", \"null\"]`\n    // which is not supported by the model API. Convert them to just `\"string\"`.\n    if (key === 'type' && Array.isArray(out[key])) {\n      // find the first that's not `null`.\n      out[key] = out[key].find((t) => t !== 'null');\n    }\n  }\n  return out;\n}\n\n/**\n * Processes the streaming body of a Response object. It decodes the stream as\n * UTF-8 text, parses JSON objects from specially formatted lines (e.g., \"data: {}\"),\n * and returns both an async generator for individual responses and a promise\n * that resolves to the aggregated final response.\n *\n * @param response The Response object with a streaming body.\n * @returns An object containing:\n *  - stream: An AsyncGenerator yielding each GenerateContentResponse.\n *  - response: A Promise resolving to the aggregated GenerateContentResponse.\n */\nexport function processStream(response: Response): GenerateContentStreamResult {\n  if (!response.body) {\n    throw new Error('Error processing stream because response.body not found');\n  }\n  const inputStream = response.body.pipeThrough(\n    new TextDecoderStream('utf8', { fatal: true })\n  );\n  const responseStream = getResponseStream(inputStream);\n  const [stream1, stream2] = responseStream.tee();\n  return {\n    stream: generateResponseSequence(stream1),\n    response: getResponsePromise(stream2),\n  };\n}\n\nfunction getResponseStream(\n  inputStream: ReadableStream<string>\n): ReadableStream<GenerateContentResponse> {\n  const responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n  const reader = inputStream.getReader();\n  const stream = new ReadableStream<GenerateContentResponse>({\n    start(controller) {\n      let currentText = '';\n      return pump();\n      function pump(): Promise<(() => Promise<void>) | undefined> {\n        return reader\n          .read()\n          .then(({ value, done }) => {\n            if (done) {\n              if (currentText.trim()) {\n                controller.error(new Error('Failed to parse stream'));\n                return;\n              }\n              controller.close();\n              return;\n            }\n\n            currentText += value;\n            let match = currentText.match(responseLineRE);\n            let parsedResponse: GenerateContentResponse;\n            while (match) {\n              try {\n                parsedResponse = JSON.parse(match[1]);\n              } catch (e) {\n                controller.error(\n                  new Error(`Error parsing JSON response: \"${match[1]}\"`)\n                );\n                return;\n              }\n              controller.enqueue(parsedResponse);\n              currentText = currentText.substring(match[0].length);\n              match = currentText.match(responseLineRE);\n            }\n            return pump();\n          })\n          .catch((e: Error) => {\n            let err = e;\n            err.stack = e.stack;\n            if (err.name === 'AbortError') {\n              err = new GenkitError({\n                status: 'ABORTED',\n                message: 'Request aborted when reading from the stream',\n              });\n            } else {\n              err = new Error('Error reading from the stream');\n            }\n            throw err;\n          });\n      }\n    },\n  });\n  return stream;\n}\n\nasync function* generateResponseSequence(\n  stream: ReadableStream<GenerateContentResponse>\n): AsyncGenerator<GenerateContentResponse> {\n  const reader = stream.getReader();\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\n\nasync function getResponsePromise(\n  stream: ReadableStream<GenerateContentResponse>\n): Promise<GenerateContentResponse> {\n  const allResponses: GenerateContentResponse[] = [];\n  const reader = stream.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      return aggregateResponses(allResponses);\n    }\n    allResponses.push(value);\n  }\n}\n\nfunction aggregateResponses(\n  responses: GenerateContentResponse[]\n): GenerateContentResponse {\n  const lastResponse = responses.at(-1);\n  if (lastResponse === undefined) {\n    throw new Error(\n      'Error aggregating stream chunks because the final response in stream chunk is undefined'\n    );\n  }\n  const aggregatedResponse: GenerateContentResponse = {};\n  if (lastResponse.promptFeedback) {\n    aggregatedResponse.promptFeedback = lastResponse.promptFeedback;\n  }\n  for (const response of responses) {\n    for (const candidate of response.candidates ?? []) {\n      const index = candidate.index ?? 0;\n      if (!aggregatedResponse.candidates) {\n        aggregatedResponse.candidates = [];\n      }\n      if (!aggregatedResponse.candidates[index]) {\n        aggregatedResponse.candidates[index] = {\n          index,\n        } as GenerateContentCandidate;\n      }\n      const aggregatedCandidate = aggregatedResponse.candidates[index];\n      aggregateMetadata(aggregatedCandidate, candidate, 'citationMetadata');\n      aggregateMetadata(aggregatedCandidate, candidate, 'groundingMetadata');\n      if (candidate.safetyRatings?.length) {\n        aggregatedCandidate.safetyRatings = (\n          aggregatedCandidate.safetyRatings ?? []\n        ).concat(candidate.safetyRatings);\n      }\n      if (candidate.finishReason !== undefined) {\n        aggregatedCandidate.finishReason = candidate.finishReason;\n      }\n      if (candidate.finishMessage !== undefined) {\n        aggregatedCandidate.finishMessage = candidate.finishMessage;\n      }\n\n      if (candidate.avgLogprobs !== undefined) {\n        aggregatedCandidate.avgLogprobs = candidate.avgLogprobs;\n      }\n      if (candidate.logprobsResult !== undefined) {\n        aggregatedCandidate.logprobsResult = candidate.logprobsResult;\n      }\n\n      /**\n       * Candidates should always have content and parts, but this handles\n       * possible malformed responses.\n       */\n      if (candidate.content && candidate.content.parts) {\n        if (!aggregatedCandidate.content) {\n          aggregatedCandidate.content = {\n            role: candidate.content.role || 'user',\n            parts: [],\n          };\n        }\n\n        for (const part of candidate.content.parts) {\n          const newPart: Partial<Part> = {};\n          if (part.thought) {\n            newPart.thought = part.thought;\n          }\n          if (part.text) {\n            newPart.text = part.text;\n          }\n          if (part.functionCall) {\n            newPart.functionCall = part.functionCall;\n          }\n          if (part.executableCode) {\n            newPart.executableCode = part.executableCode;\n          }\n          if (part.codeExecutionResult) {\n            newPart.codeExecutionResult = part.codeExecutionResult;\n          }\n          if (Object.keys(newPart).length === 0) {\n            newPart.text = '';\n          }\n          aggregatedCandidate.content.parts.push(newPart as Part);\n        }\n      }\n    }\n    if (response.usageMetadata) {\n      aggregatedResponse.usageMetadata = response.usageMetadata;\n    }\n  }\n  return aggregatedResponse;\n}\n\nfunction aggregateMetadata<K extends keyof GenerateContentCandidate>(\n  aggCandidate: GenerateContentCandidate,\n  chunkCandidate: GenerateContentCandidate,\n  fieldName: K\n) {\n  const chunkObj = chunkCandidate[fieldName];\n  const aggObj = aggCandidate[fieldName];\n  if (chunkObj === undefined) return; // Nothing to do\n\n  if (aggObj === undefined) {\n    aggCandidate[fieldName] = chunkObj;\n    return;\n  }\n\n  if (isObject(chunkObj)) {\n    for (const k of Object.keys(chunkObj)) {\n      if (Array.isArray(aggObj[k]) && Array.isArray(chunkObj[k])) {\n        aggObj[k] = aggObj[k].concat(chunkObj[k]);\n      } else {\n        // last one wins, also handles only one being an array.\n        aggObj[k] = chunkObj[k] ?? aggObj[k];\n      }\n    }\n  }\n}\n\nexport function getGenkitClientHeader() {\n  if (process.env.MONOSPACE_ENV == 'true') {\n    return defaultGetClientHeader() + ' firebase-studio-vm';\n  }\n  return defaultGetClientHeader();\n}\n"],"names":["media","defaultGetClientHeader"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/client.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  extractErrMsg,\n  getGenkitClientHeader,\n  processStream,\n} from '../common/utils.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbedContentResponse,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ListModelsResponse,\n  Model,\n  VeoOperation,\n  VeoPredictRequest,\n} from './types.js';\n\n/**\n * Lists available models.\n *\n * https://ai.google.dev/api/models#method:-models.list\n *\n * @param apiKey The API key to authenticate the request.\n * @param clientOptions Optional options to customize the request\n * @returns A promise that resolves to an array of Model objects.\n */\nexport async function listModels(\n  apiKey: string,\n  clientOptions?: ClientOptions\n): Promise<Model[]> {\n  const url = getGoogleAIUrl({\n    resourcePath: 'models',\n    queryParams: 'pageSize=1000',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'GET',\n    apiKey,\n    clientOptions,\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = JSON.parse(await response.text()) as ListModelsResponse;\n  return modelResponse.models;\n}\n\n/**\n * Generates content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content generation.\n * @param {GenerateContentRequest} generateContentRequest The request object containing the content generation parameters.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<GenerateContentResponse>} A promise that resolves to the content generation response.\n * @throws {Error} If the API request fails or the response cannot be parsed.\n */\nexport async function generateContent(\n  apiKey: string,\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions?: ClientOptions\n): Promise<GenerateContentResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'generateContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n\n  const responseJson = (await response.json()) as GenerateContentResponse;\n  return responseJson;\n}\n\n/**\n * Generates a stream of content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content generation.\n * @param {GenerateContentRequest} generateContentRequest The request object containing the content generation parameters.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<GenerateContentStreamResult>} A promise that resolves to an object containing a both the stream and aggregated response.\n * @throws {Error} If the API request fails.\n */\nexport async function generateContentStream(\n  apiKey: string,\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions?: ClientOptions\n): Promise<GenerateContentStreamResult> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'streamGenerateContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return processStream(response);\n}\n\n/**\n * Embeds content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content embedding.\n * @param {EmbedContentRequest} embedContentRequest The request object containing the content to embed.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<EmbedContentResponse>} A promise that resolves to the embedding response.\n * @throws {Error} If the API request fails or the response cannot be parsed.\n */\nexport async function embedContent(\n  apiKey: string,\n  model: string,\n  embedContentRequest: EmbedContentRequest,\n  clientOptions?: ClientOptions\n): Promise<EmbedContentResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'embedContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(embedContentRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\n\nexport async function imagenPredict(\n  apiKey: string,\n  model: string,\n  imagenPredictRequest: ImagenPredictRequest,\n  clientOptions?: ClientOptions\n): Promise<ImagenPredictResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'predict',\n    clientOptions,\n  });\n\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(imagenPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<ImagenPredictResponse>;\n}\n\nexport async function veoPredict(\n  apiKey: string,\n  model: string,\n  veoPredictRequest: VeoPredictRequest,\n  clientOptions?: ClientOptions\n): Promise<VeoOperation> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'predictLongRunning',\n    clientOptions,\n  });\n\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\nexport async function veoCheckOperation(\n  apiKey: string,\n  operation: string,\n  clientOptions?: ClientOptions\n): Promise<VeoOperation> {\n  const url = getGoogleAIUrl({\n    resourcePath: operation,\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'GET',\n    apiKey,\n    clientOptions,\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\n/**\n * Generates a Google AI URL.\n *\n * @param params - An object containing the parameters for the URL.\n * @param params.path - The path for the URL (the part after the version)\n * @param params.task - An optional task\n * @param params.queryParams - An optional string of '&' delimited query parameters.\n * @param params.clientOptions - An optional object containing client options.\n * @returns The generated Google AI URL.\n */\nexport function getGoogleAIUrl(params: {\n  resourcePath: string;\n  resourceMethod?: string;\n  queryParams?: string;\n  clientOptions?: ClientOptions;\n}): string {\n  // v1beta is the default because all the new experimental models\n  // are found here but not in v1.\n  const DEFAULT_API_VERSION = 'v1beta';\n  const DEFAULT_BASE_URL = 'https://generativelanguage.googleapis.com';\n\n  const apiVersion = params.clientOptions?.apiVersion || DEFAULT_API_VERSION;\n  const baseUrl = params.clientOptions?.baseUrl || DEFAULT_BASE_URL;\n\n  let url = `${baseUrl}/${apiVersion}/${params.resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n  if (params.queryParams) {\n    url += `?${params.queryParams}`;\n  }\n  if (params.resourceMethod === 'streamGenerateContent') {\n    url += `${params.queryParams ? '&' : '?'}alt=sse`;\n  }\n  return url;\n}\n\nfunction getFetchOptions(params: {\n  method: 'POST' | 'GET';\n  apiKey: string;\n  body?: string;\n  clientOptions?: ClientOptions;\n}) {\n  const fetchOptions: RequestInit = {\n    method: params.method,\n    headers: getHeaders(params.apiKey, params.clientOptions),\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\n\nfunction getAbortSignal(\n  clientOptions?: ClientOptions\n): AbortSignal | undefined {\n  const hasTimeout = (clientOptions?.timeout ?? -1) >= 0;\n  if (clientOptions?.signal !== undefined || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions?.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener('abort', () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return undefined;\n}\n\n/**\n * Constructs the headers for an API request.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {ClientOptions} [clientOptions] Optional client options, containing custom headers.\n * @returns {HeadersInit} An object containing the headers to be included in the request.\n */\nfunction getHeaders(\n  apiKey: string,\n  clientOptions?: ClientOptions\n): HeadersInit {\n  let customHeaders = {};\n  if (clientOptions?.customHeaders) {\n    customHeaders = structuredClone(clientOptions.customHeaders);\n    delete customHeaders['x-goog-api-key']; // Not allowed in user settings\n    delete customHeaders['x-goog-api-client']; // Not allowed in user settings\n  }\n  const headers: HeadersInit = {\n    ...customHeaders,\n    'Content-Type': 'application/json',\n    'x-goog-api-key': apiKey,\n    'x-goog-api-client': getGenkitClientHeader(),\n  };\n\n  return headers;\n}\n\n/**\n * Makes a request to the specified URL with the provided options.\n *\n * @param {string} url The URL to make the request to.\n * @param {RequestInit} fetchOptions The options to pass to the `fetch` API.\n * @returns {Promise<Response>} A promise that resolves to the Response\n * @throws {Error} If the request fails\n */\nasync function makeRequest(\n  url: string,\n  fetchOptions: RequestInit\n): Promise<Response> {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n        // Not JSON or expected format, use the raw text\n      }\n      throw new Error(\n        `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`\n      );\n    }\n    return response;\n  } catch (e: unknown) {\n    console.error(e);\n    throw new Error(`Failed to fetch from ${url}: ${extractErrMsg(e)}`);\n  }\n}\n\nexport const TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateRequest, GenkitError } from 'genkit';\nimport process from 'process';\nimport { extractMedia } from '../common/utils.js';\nimport { ImagenInstance, VeoImage } from './types.js';\n\nexport {\n  checkModelName,\n  cleanSchema,\n  extractText,\n  extractVersion,\n  modelName,\n} from '../common/utils.js';\n\n/**\n * Retrieves an API key from environment variables.\n *\n * @returns The API key as a string, or `undefined` if none of the specified\n *          environment variables are set.\n */\nexport function getApiKeyFromEnvVar(): string | undefined {\n  return (\n    process.env.GEMINI_API_KEY ||\n    process.env.GOOGLE_API_KEY ||\n    process.env.GOOGLE_GENAI_API_KEY\n  );\n}\n\nexport const MISSING_API_KEY_ERROR = new GenkitError({\n  status: 'FAILED_PRECONDITION',\n  message:\n    'Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\\n' +\n    'For more details see https://genkit.dev/docs/plugins/google-genai/',\n});\n\nexport const API_KEY_FALSE_ERROR = new GenkitError({\n  status: 'INVALID_ARGUMENT',\n  message:\n    'GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.',\n});\n\n/**\n * Checks and retrieves an API key based on the provided argument and environment variables.\n *\n * - If `pluginApiKey` is a non-empty string, it's used as the API key.\n * - If `pluginApiKey` is `undefined` or an empty string, it attempts to fetch the API key from environment\n * - If `pluginApiKey` is `false`, key retrieval from the environment is skipped, and the function\n *   will return `undefined`. This mode indicates that the API key is expected to be provided\n *   at a later stage or in a different context.\n *\n * @param pluginApiKey - An optional API key string, `undefined` to check the environment, or `false` to bypass all checks in this function.\n * @returns The resolved API key as a string, or `undefined` if `pluginApiKey` is `false`.\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if `pluginApiKey` is not `false` and no API key\n *   can be found either in the `pluginApiKey` argument or from the environment.\n */\nexport function checkApiKey(\n  pluginApiKey: string | false | undefined\n): string | undefined {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  // If pluginApiKey is false, then we don't throw because we are waiting for\n  // the apiKey passed into the individual call\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/**\n * Calculates and returns the effective API key based on multiple potential sources.\n * The order of precedence for determining the API key is:\n * 1. `requestApiKey` (if provided)\n * 2. `pluginApiKey` (if provided and not `false`)\n * 3. Environment variable (if `pluginApiKey` is not `false` and `pluginApiKey` is not provided)\n *\n * @param pluginApiKey - The apiKey value provided during plugin initialization.\n * @param requestApiKey - The apiKey provided to an individual generate call.\n * @returns The resolved API key as a string.\n * @throws {Error} API_KEY_FALSE_ERROR - Thrown if `pluginApiKey` is `false` and `requestApiKey` is not provided\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if no API key can be resolved from any source\n */\nexport function calculateApiKey(\n  pluginApiKey: string | false | undefined,\n  requestApiKey: string | undefined\n): string {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  apiKey = requestApiKey || apiKey;\n\n  if (pluginApiKey === false && !requestApiKey) {\n    throw API_KEY_FALSE_ERROR;\n  }\n\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\nexport function extractVeoImage(\n  request: GenerateRequest\n): VeoImage | undefined {\n  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;\n  if (media) {\n    const img = media.url.split(',')[1];\n    if (img && media.contentType) {\n      return {\n        bytesBase64Encoded: img,\n        mimeType: media.contentType!,\n      };\n    } else if (img) {\n      // Content Type is not optional\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: 'content type is required for images',\n      });\n    }\n  }\n  return undefined;\n}\n\nexport function extractImagenImage(\n  request: GenerateRequest\n): ImagenInstance['image'] | undefined {\n  const image = extractMedia(request, {\n    metadataType: 'base',\n    isDefault: true,\n  })?.url.split(',')[1];\n\n  if (image) {\n    return { bytesBase64Encoded: image };\n  }\n  return undefined;\n}\n"],"names":["import_utils","process"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,qBAAA,IAAA;IAAA,uBAAA,IAAA;IAAA,iBAAA,IAAA;IAAA,aAAA,IAAA;IAAA,gBAAA,IAAA,cAAA,cAAA;IAAA,aAAA,IAAA,cAAA,WAAA;IAAA,oBAAA,IAAA;IAAA,aAAA,IAAA,cAAA,WAAA;IAAA,iBAAA,IAAA;IAAA,gBAAA,IAAA,cAAA,cAAA;IAAA,qBAAA,IAAA;IAAA,WAAA,IAAA,cAAA,SAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAgBA,IAAA,gBAA6C;AAC7C,IAAA,iBAAoB;AACpB,IAAA,eAA6B;AAG7B,IAAAA,gBAMO;AAQA,SAAS,sBAA0C;IACxD,OACE,eAAAC,OAAAA,CAAQ,GAAA,CAAI,cAAA,IACZ,eAAAA,OAAAA,CAAQ,GAAA,CAAI,cAAA,IACZ,eAAAA,OAAAA,CAAQ,GAAA,CAAI,oBAAA;AAEhB;AAEO,MAAM,wBAAwB,IAAI,cAAA,WAAA,CAAY;IACnD,QAAQ;IACR,SACE;AAEJ,CAAC;AAEM,MAAM,sBAAsB,IAAI,cAAA,WAAA,CAAY;IACjD,QAAQ;IACR,SACE;AACJ,CAAC;AAgBM,SAAS,YACd,YAAA,EACoB;IACpB,IAAI;IAGJ,IAAI,iBAAiB,OAAO;QAC1B,SAAS,gBAAgB,oBAAoB;IAC/C;IAIA,IAAI,iBAAiB,SAAS,CAAC,QAAQ;QACrC,MAAM;IACR;IACA,OAAO;AACT;AAeO,SAAS,gBACd,YAAA,EACA,aAAA,EACQ;IACR,IAAI;IAGJ,IAAI,iBAAiB,OAAO;QAC1B,SAAS,gBAAgB,oBAAoB;IAC/C;IAEA,SAAS,iBAAiB;IAE1B,IAAI,iBAAiB,SAAS,CAAC,eAAe;QAC5C,MAAM;IACR;IAEA,IAAI,CAAC,QAAQ;QACX,MAAM;IACR;IACA,OAAO;AACT;AAEO,SAAS,gBACd,OAAA,EACsB;IACtB,MAAM,QAAQ,QAAQ,QAAA,CAAS,EAAA,CAAG,CAAA,CAAE,GAAG,QAAQ,KAAK,CAAC,IAAM,CAAC,CAAC,EAAE,KAAK,GAAG;IACvE,IAAI,OAAO;QACT,MAAM,MAAM,MAAM,GAAA,CAAI,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA;QAClC,IAAI,OAAO,MAAM,WAAA,EAAa;YAC5B,OAAO;gBACL,oBAAoB;gBACpB,UAAU,MAAM,WAAA;YAClB;QACF,OAAA,IAAW,KAAK;YAEd,MAAM,IAAI,cAAA,WAAA,CAAY;gBACpB,QAAQ;gBACR,SAAS;YACX,CAAC;QACH;IACF;IACA,OAAO,KAAA;AACT;AAEO,SAAS,mBACd,OAAA,EACqC;IACrC,MAAM,QAAA,CAAA,GAAQ,aAAA,YAAA,EAAa,SAAS;QAClC,cAAc;QACd,WAAW;IACb,CAAC,GAAG,IAAI,MAAM,GAAG,CAAA,CAAE,CAAC,CAAA;IAEpB,IAAI,OAAO;QACT,OAAO;YAAE,oBAAoB;QAAM;IACrC;IACA,OAAO,KAAA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 940, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Content,\n  FinishReason,\n  GenerateContentCandidate,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  GenerationConfig,\n  GoogleSearchRetrievalTool,\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  Part,\n  SafetySetting,\n  TaskType,\n  TaskTypeSchema,\n  Tool,\n  ToolConfig,\n} from '../common/types.js';\n\n// This makes it easier to import all types from one place.\nexport {\n  FinishReason,\n  HarmBlockThreshold,\n  HarmCategory,\n  TaskTypeSchema,\n  type Content,\n  type GenerateContentCandidate,\n  type GenerateContentRequest,\n  type GenerateContentResponse,\n  type GenerateContentStreamResult,\n  type GenerationConfig,\n  type GoogleSearchRetrievalTool,\n  type ImagenInstance,\n  type ImagenParameters,\n  type ImagenPredictRequest,\n  type ImagenPredictResponse,\n  type ImagenPrediction,\n  type Part,\n  type SafetySetting,\n  type Tool,\n  type ToolConfig,\n};\n\nexport interface GoogleAIPluginOptions {\n  /**\n   * Provide the API key to use to authenticate with the Gemini API. By\n   * default, an API key must be provided explicitly here or through the\n   * `GEMINI_API_KEY` or `GOOGLE_API_KEY` environment variables.\n   *\n   * If `false` is explicitly passed, the plugin will be configured to\n   * expect an `apiKey` option to be provided to the model config at\n   * call time.\n   **/\n  apiKey?: string | false;\n  apiVersion?: string;\n  baseUrl?: string;\n  experimental_debugTraces?: boolean;\n}\n\n/**\n * Options passed to the client\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * An object that may be used to abort asynchronous requests. The request may\n   * also be aborted due to the expiration of the timeout value, if provided.\n   *\n   * NOTE: AbortSignal is a client-only operation. Using it to cancel an\n   * operation will not cancel the request in the service. You will still\n   * be charged usage for any applicable operations.\n   */\n  signal?: AbortSignal;\n  /**\n   * Request timeout in milliseconds.\n   */\n  timeout?: number;\n  /**\n   * Version of API endpoint to call (e.g. \"v1\" or \"v1beta\"). If not specified,\n   * defaults to 'v1beta'.\n   */\n  apiVersion?: string;\n  /**\n   * Additional attribution information to include in the x-goog-api-client header.\n   * Used by wrapper SDKs.\n   */\n  apiClient?: string;\n  /**\n   * Base endpoint url. Defaults to \"https://generativelanguage.googleapis.com\"\n   */\n  baseUrl?: string;\n  /**\n   * Custom HTTP request headers.\n   */\n  customHeaders?: Headers | Record<string, string>;\n}\n\n/**\n * Params for calling embedContent\n * @public\n */\nexport interface EmbedContentRequest {\n  content: Content;\n  taskType?: TaskType;\n  title?: string;\n}\n\n/**\n * Gemini model object\n * @public\n */\nexport interface Model {\n  name: string;\n  baseModelId: string;\n  version: string;\n  displayName: string;\n  description: string;\n  inputTokenLimit: number;\n  outputTokenLimit: number;\n  supportedGenerationMethods: string[];\n  temperature: number;\n  maxTemperature: number;\n  topP: number;\n  topK: number;\n}\n\n/**\n * Response from calling listModels\n * @public\n */\nexport interface ListModelsResponse {\n  models: Model[];\n  nextPageToken?: string;\n}\n\n/**\n * Response from calling embedContent\n * @public\n */\nexport interface EmbedContentResponse {\n  embedding: ContentEmbedding;\n}\n\n/**\n * A single content embedding.\n * @public\n */\nexport interface ContentEmbedding {\n  values: number[];\n}\n\nexport declare interface VeoPredictRequest {\n  instances: VeoInstance[];\n  parameters: VeoParameters;\n}\n\nexport declare interface VeoParameters {\n  negativePrompt?: string;\n  aspectRatio?: string;\n  personGeneration?: string;\n  durationSeconds?: number;\n  enhancePrompt?: boolean;\n}\n\nexport declare interface VeoInstance {\n  prompt: string;\n  image?: VeoImage;\n}\n\nexport declare interface VeoImage {\n  bytesBase64Encoded: string;\n  mimeType: string;\n}\n\nexport declare interface VeoOperation {\n  name: string;\n  done?: boolean;\n  error?: {\n    message: string;\n  };\n  response?: {\n    generateVideoResponse: {\n      generatedSamples: { video: { uri: string } }[];\n    };\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,oBAAA,IAAA,aAAA,kBAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,gBAAA,IAAA,aAAA,cAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAgBA,IAAA,eAsBO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/embedder.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  EmbedderAction,\n  embedderActionMetadata,\n  EmbedderInfo,\n  EmbedderReference,\n  Genkit,\n  z,\n} from 'genkit';\nimport { embedderRef } from 'genkit/embedder';\nimport { embedContent } from './client.js';\nimport {\n  EmbedContentRequest,\n  GoogleAIPluginOptions,\n  Model,\n  TaskTypeSchema,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkApiKey,\n  checkModelName,\n  extractVersion,\n} from './utils.js';\n\nexport const EmbeddingConfigSchema = z\n  .object({\n    /** Override the API key provided at plugin initialization. */\n    apiKey: z.string().optional(),\n    /**\n     * The `task_type` parameter is defined as the intended downstream application to help the model\n     * produce better quality embeddings.\n     **/\n    taskType: TaskTypeSchema.optional(),\n    title: z.string().optional(),\n    version: z.string().optional(),\n    /**\n     * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n     * By default, the model generates embeddings with 768 dimensions. Models such as\n     * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`\n     * allow the output dimensionality to be adjusted between 1 and 768.\n     * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n     **/\n    outputDimensionality: z.number().min(1).optional(),\n  })\n  .passthrough();\nexport type EmbeddingConfigSchemaType = typeof EmbeddingConfigSchema;\nexport type EmbeddingConfig = z.infer<EmbeddingConfigSchemaType>;\n\n// This contains all the embedder config schema types\ntype ConfigSchemaType = EmbeddingConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: EmbedderInfo,\n  configSchema: ConfigSchemaType = EmbeddingConfigSchema\n): EmbedderReference<ConfigSchemaType> {\n  return embedderRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: ['text'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('embedder');\n\nconst KNOWN_MODELS = {\n  'text-embedding-004': commonRef('text-embedding-004'),\n  'gemini-embedding-001': commonRef('gemini-embedding-001'),\n};\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\n\nexport function model(\n  version: string,\n  config: EmbeddingConfig = {}\n): EmbedderReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return embedderRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GENERIC_MODEL.configSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter((m) => m.supportedGenerationMethods.includes('embedContent'))\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return embedderActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function defineKnownModels(ai: Genkit, options?: GoogleAIPluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineEmbedder(ai, name, options);\n  }\n}\n\nexport function defineEmbedder(\n  ai: Genkit,\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): EmbedderAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n\n  return ai.defineEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info,\n    },\n    async (input, reqOptions) => {\n      const embedApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        reqOptions?.apiKey\n      );\n      const embedVersion = reqOptions?.version || extractVersion(ref);\n\n      const embeddings = await Promise.all(\n        input.map(async (doc) => {\n          const response = await embedContent(embedApiKey, embedVersion, {\n            taskType: reqOptions?.taskType,\n            title: reqOptions?.title,\n            content: {\n              role: '',\n              parts: [{ text: doc.text }],\n            },\n            outputDimensionality: reqOptions?.outputDimensionality,\n          } as EmbedContentRequest);\n          const values = response.embedding.values;\n          return { embedding: values };\n        })\n      );\n      return { embeddings };\n    }\n  );\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/common/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, z } from 'genkit';\nimport {\n  CandidateData,\n  MessageData,\n  ModelReference,\n  Part,\n  ToolDefinition,\n} from 'genkit/model';\nimport {\n  FunctionCallingMode,\n  FunctionDeclaration,\n  GenerateContentCandidate as GeminiCandidate,\n  Content as GeminiContent,\n  Part as GeminiPart,\n  Schema,\n  SchemaType,\n} from './types.js';\n\nexport function toGeminiTool(tool: ToolDefinition): FunctionDeclaration {\n  const declaration: FunctionDeclaration = {\n    name: tool.name.replace(/\\//g, '__'), // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: toGeminiSchemaProperty(tool.inputSchema),\n  };\n  return declaration;\n}\n\nfunction toGeminiSchemaProperty(property?: ToolDefinition['inputSchema']) {\n  if (!property || !property.type) {\n    return undefined;\n  }\n  const baseSchema: Schema = {};\n  if (property.description) {\n    baseSchema.description = property.description;\n  }\n  if (property.enum) {\n    baseSchema.enum = property.enum;\n  }\n  if (property.nullable) {\n    baseSchema.nullable = property.nullable;\n  }\n  let propertyType;\n  // nullable schema can ALSO be defined as, for example, type=['string','null']\n  if (Array.isArray(property.type)) {\n    const types = property.type as string[];\n    if (types.includes('null')) {\n      baseSchema.nullable = true;\n    }\n    // grab the type that's not `null`\n    propertyType = types.find((t) => t !== 'null');\n  } else {\n    propertyType = property.type;\n  }\n  if (propertyType === 'object') {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);\n    });\n    return {\n      ...baseSchema,\n      type: SchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required,\n    };\n  } else if (propertyType === 'array') {\n    return {\n      ...baseSchema,\n      type: SchemaType.ARRAY,\n      items: toGeminiSchemaProperty(property.items),\n    };\n  } else {\n    const schemaType = SchemaType[propertyType.toUpperCase()] as SchemaType;\n    if (!schemaType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `Unsupported property type ${propertyType.toUpperCase()}`,\n      });\n    }\n    return {\n      ...baseSchema,\n      type: schemaType,\n    };\n  }\n}\n\nfunction toGeminiMedia(part: Part): GeminiPart {\n  if (part.media?.url.startsWith('data:')) {\n    // Inline data\n    const dataUrl = part.media.url;\n    const b64Data = dataUrl.substring(dataUrl.indexOf(',')! + 1);\n    const contentType =\n      part.media.contentType ||\n      dataUrl.substring(dataUrl.indexOf(':')! + 1, dataUrl.indexOf(';'));\n    return { inlineData: { mimeType: contentType, data: b64Data } };\n  }\n\n  // File data\n  if (!part.media?.contentType) {\n    throw Error(\n      'Must supply a `contentType` when sending File URIs to Gemini.'\n    );\n  }\n  return {\n    fileData: {\n      mimeType: part.media.contentType,\n      fileUri: part.media.url,\n    },\n  };\n}\n\nfunction toGeminiToolRequest(part: Part): GeminiPart {\n  if (!part.toolRequest?.input) {\n    throw Error('Invalid ToolRequestPart: input was missing.');\n  }\n  return {\n    functionCall: {\n      name: part.toolRequest.name,\n      args: part.toolRequest.input,\n    },\n  };\n}\n\nfunction toGeminiToolResponse(part: Part): GeminiPart {\n  if (!part.toolResponse?.output) {\n    throw Error('Invalid ToolResponsePart: output was missing.');\n  }\n  return {\n    functionResponse: {\n      name: part.toolResponse.name,\n      response: {\n        name: part.toolResponse.name,\n        content: part.toolResponse.output,\n      },\n    },\n  };\n}\n\nfunction toGeminiReasoning(part: Part): GeminiPart {\n  const out: GeminiPart = { thought: true };\n  if (typeof part.metadata?.thoughtSignature === 'string') {\n    out.thoughtSignature = part.metadata.thoughtSignature;\n  }\n  if (part.reasoning?.length) {\n    out.text = part.reasoning;\n  }\n  return out;\n}\n\nfunction toGeminiCustom(part: Part): GeminiPart {\n  if (part.custom?.codeExecutionResult) {\n    return {\n      codeExecutionResult: part.custom.codeExecutionResult,\n    };\n  }\n  if (part.custom?.executableCode) {\n    return {\n      executableCode: part.custom.executableCode,\n    };\n  }\n  throw new Error('Unsupported Custom Part type');\n}\n\nfunction toGeminiPart(part: Part): GeminiPart {\n  if (part.text) {\n    return { text: part.text };\n  }\n  if (part.media) {\n    return toGeminiMedia(part);\n  }\n  if (part.toolRequest) {\n    return toGeminiToolRequest(part);\n  }\n  if (part.toolResponse) {\n    return toGeminiToolResponse(part);\n  }\n  if (typeof part.reasoning === 'string') {\n    return toGeminiReasoning(part);\n  }\n  if (part.custom) {\n    return toGeminiCustom(part);\n  }\n  throw new Error('Unsupported Part type ' + JSON.stringify(part));\n}\n\nfunction toGeminiRole(\n  role: MessageData['role'],\n  model?: ModelReference<z.ZodTypeAny>\n): string {\n  switch (role) {\n    case 'user':\n      return 'user';\n    case 'model':\n      return 'model';\n    case 'system':\n      if (model?.info?.supports?.systemRole) {\n        // We should have already pulled out the supported system messages,\n        // anything remaining is unsupported; throw an error.\n        throw new Error(\n          'system role is only supported for a single message in the first position'\n        );\n      } else {\n        throw new Error('system role is not supported');\n      }\n    case 'tool':\n      return 'function';\n    default:\n      return 'user';\n  }\n}\n\nexport function toGeminiMessage(\n  message: MessageData,\n  model?: ModelReference<z.ZodTypeAny>\n): GeminiContent {\n  let sortedParts = message.content;\n  if (message.role === 'tool') {\n    sortedParts = [...message.content].sort((a, b) => {\n      const aRef = a.toolResponse?.ref;\n      const bRef = b.toolResponse?.ref;\n      if (!aRef && !bRef) return 0;\n      if (!aRef) return 1;\n      if (!bRef) return -1;\n      return parseInt(aRef, 10) - parseInt(bRef, 10);\n    });\n  }\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: sortedParts.map(toGeminiPart),\n  };\n}\n\nexport function toGeminiSystemInstruction(message: MessageData): GeminiContent {\n  return {\n    role: 'user',\n    parts: message.content.map(toGeminiPart),\n  };\n}\n\n/**\n * Converts mode from either genkit tool choice (lowercase)\n * or functionCallingConfig (uppercase).\n * @param from The mode to convert from\n * @returns\n */\nexport function toGeminiFunctionModeEnum(\n  from?: string\n  //genkitMode: 'auto' | 'required' | 'none'\n): FunctionCallingMode | undefined {\n  if (from === undefined) {\n    return undefined;\n  }\n  switch (from) {\n    case 'MODE_UNSPECIFIED': {\n      return FunctionCallingMode.MODE_UNSPECIFIED;\n    }\n    case 'required':\n    case 'ANY': {\n      return FunctionCallingMode.ANY;\n    }\n    case 'auto':\n    case 'AUTO': {\n      return FunctionCallingMode.AUTO;\n    }\n    case 'none':\n    case 'NONE': {\n      return FunctionCallingMode.NONE;\n    }\n    default:\n      throw new Error(`unsupported function calling mode: ${from}`);\n  }\n}\n\nfunction fromGeminiFinishReason(\n  reason: GeminiCandidate['finishReason']\n): CandidateData['finishReason'] {\n  if (!reason) return 'unknown';\n  switch (reason) {\n    case 'STOP':\n      return 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'SAFETY': // blocked for safety\n    case 'RECITATION': // blocked for reciting training data\n    case 'LANGUAGE': // blocked for using an unsupported language\n    case 'BLOCKLIST': // blocked for forbidden terms\n    case 'PROHIBITED_CONTENT': // blocked for potentially containing prohibited content\n    case 'SPII': // blocked for potentially containing Sensitive Personally Identifiable Information\n      return 'blocked';\n    case 'MALFORMED_FUNCTION_CALL':\n    case 'OTHER':\n      return 'other';\n    default:\n      return 'unknown';\n  }\n}\n\nfunction fromGeminiThought(part: GeminiPart): Part {\n  return {\n    reasoning: part.text || '',\n    metadata: { thoughtSignature: part.thoughtSignature },\n  };\n}\n\nfunction fromGeminiInlineData(part: GeminiPart): Part {\n  // Check if the required properties exist\n  if (\n    !part.inlineData ||\n    !part.inlineData.hasOwnProperty('mimeType') ||\n    !part.inlineData.hasOwnProperty('data')\n  ) {\n    throw new Error('Invalid GeminiPart: missing required properties');\n  }\n  const { mimeType, data } = part.inlineData;\n  // Combine data and mimeType into a data URL\n  const dataUrl = `data:${mimeType};base64,${data}`;\n  return {\n    media: {\n      url: dataUrl,\n      contentType: mimeType,\n    },\n  };\n}\n\nfunction fromGeminiFileData(part: GeminiPart): Part {\n  if (\n    !part.fileData ||\n    !part.fileData.hasOwnProperty('mimeType') ||\n    !part.fileData.hasOwnProperty('fileUri')\n  ) {\n    throw new Error(\n      'Invalid Gemini File Data Part: missing required properties'\n    );\n  }\n\n  return {\n    media: {\n      url: part.fileData?.fileUri,\n      contentType: part.fileData?.mimeType,\n    },\n  };\n}\n\nfunction fromGeminiFunctionCall(part: GeminiPart, ref: string): Part {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  return {\n    toolRequest: {\n      name: part.functionCall.name,\n      input: part.functionCall.args,\n      ref,\n    },\n  };\n}\n\nfunction fromGeminiFunctionResponse(part: GeminiPart, ref?: string): Part {\n  if (!part.functionResponse) {\n    throw new Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  return {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, '/'), // restore slashes\n      output: part.functionResponse.response,\n      ref,\n    },\n  };\n}\n\nfunction fromExecutableCode(part: GeminiPart): Part {\n  if (!part.executableCode) {\n    throw new Error('Invalid GeminiPart: missing executableCode');\n  }\n  return {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code,\n      },\n    },\n  };\n}\n\nfunction fromCodeExecutionResult(part: GeminiPart): Part {\n  if (!part.codeExecutionResult) {\n    throw new Error('Invalid GeminiPart: missing codeExecutionResult');\n  }\n  return {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output,\n      },\n    },\n  };\n}\n\nfunction fromGeminiPart(part: GeminiPart, ref: string): Part {\n  if (part.thought) return fromGeminiThought(part as any);\n  if (typeof part.text === 'string') return { text: part.text };\n  if (part.inlineData) return fromGeminiInlineData(part);\n  if (part.fileData) return fromGeminiFileData(part);\n  if (part.functionCall) return fromGeminiFunctionCall(part, ref);\n  if (part.functionResponse) return fromGeminiFunctionResponse(part, ref);\n  if (part.executableCode) return fromExecutableCode(part);\n  if (part.codeExecutionResult) return fromCodeExecutionResult(part);\n\n  throw new Error('Unsupported GeminiPart type ' + JSON.stringify(part));\n}\n\nexport function fromGeminiCandidate(candidate: GeminiCandidate): CandidateData {\n  const parts = candidate.content?.parts || [];\n  const genkitCandidate: CandidateData = {\n    index: candidate.index || 0,\n    message: {\n      role: 'model',\n      content: parts\n        // the model sometimes returns empty parts, ignore those.\n        .filter((p) => Object.keys(p).length > 0)\n        .map((part, index) => fromGeminiPart(part, index.toString())),\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata,\n    },\n  };\n\n  return genkitCandidate;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1550, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/gemini.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  Genkit,\n  GenkitError,\n  modelActionMetadata,\n  z,\n} from 'genkit';\nimport {\n  GenerationCommonConfigDescriptions,\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelMiddleware,\n  ModelReference,\n  getBasicUsageStats,\n  modelRef,\n} from 'genkit/model';\nimport { downloadRequestMedia } from 'genkit/model/middleware';\nimport { runInNewSpan } from 'genkit/tracing';\nimport {\n  fromGeminiCandidate,\n  toGeminiFunctionModeEnum,\n  toGeminiMessage,\n  toGeminiSystemInstruction,\n  toGeminiTool,\n} from '../common/converters.js';\nimport {\n  generateContent,\n  generateContentStream,\n  getGoogleAIUrl,\n} from './client.js';\nimport {\n  ClientOptions,\n  Content as GeminiMessage,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerationConfig,\n  GoogleAIPluginOptions,\n  GoogleSearchRetrievalTool,\n  Model,\n  SafetySetting,\n  Tool,\n  ToolConfig,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkApiKey,\n  checkModelName,\n  cleanSchema,\n  extractVersion,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/safety-settings#safety-filters.\n */\nconst SafetySettingsSchema = z.object({\n  category: z.enum([\n    'HARM_CATEGORY_UNSPECIFIED',\n    'HARM_CATEGORY_HATE_SPEECH',\n    'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n    'HARM_CATEGORY_HARASSMENT',\n    'HARM_CATEGORY_DANGEROUS_CONTENT',\n  ]),\n  threshold: z.enum([\n    'BLOCK_LOW_AND_ABOVE',\n    'BLOCK_MEDIUM_AND_ABOVE',\n    'BLOCK_ONLY_HIGH',\n    'BLOCK_NONE',\n  ]),\n});\n\nconst VoiceConfigSchema = z\n  .object({\n    prebuiltVoiceConfig: z\n      .object({\n        // TODO: Make this an array of objects so we can also specify the description\n        // for each voiceName.\n        voiceName: z\n          .union([\n            z.enum([\n              'Zephyr',\n              'Puck',\n              'Charon',\n              'Kore',\n              'Fenrir',\n              'Leda',\n              'Orus',\n              'Aoede',\n              'Callirrhoe',\n              'Autonoe',\n              'Enceladus',\n              'Iapetus',\n              'Umbriel',\n              'Algieba',\n              'Despina',\n              'Erinome',\n              'Algenib',\n              'Rasalgethi',\n              'Laomedeia',\n              'Achernar',\n              'Alnilam',\n              'Schedar',\n              'Gacrux',\n              'Pulcherrima',\n              'Achird',\n              'Zubenelgenubi',\n              'Vindemiatrix',\n              'Sadachbia',\n              'Sadaltager',\n              'Sulafat',\n            ]),\n            // To allow any new string values\n            z.string(),\n          ])\n          .describe('Name of the preset voice to use')\n          .optional(),\n      })\n      .describe('Configuration for the prebuilt speaker to use')\n      .passthrough()\n      .optional(),\n  })\n  .describe('Configuration for the voice to use')\n  .passthrough();\n\nexport const GeminiConfigSchema = GenerationCommonConfigSchema.extend({\n  apiKey: z\n    .string()\n    .describe('Overrides the plugin-configured API key, if specified.')\n    .optional(),\n  safetySettings: z\n    .array(SafetySettingsSchema)\n    .describe(\n      'Adjust how likely you are to see responses that could be harmful. ' +\n        'Content is blocked based on the probability that it is harmful.'\n    )\n    .optional(),\n  codeExecution: z\n    .union([z.boolean(), z.object({}).strict()])\n    .describe('Enables the model to generate and run code.')\n    .optional(),\n  contextCache: z\n    .boolean()\n    .describe(\n      'Context caching allows you to save and reuse precomputed input ' +\n        'tokens that you wish to use repeatedly.'\n    )\n    .optional(),\n  functionCallingConfig: z\n    .object({\n      mode: z.enum(['MODE_UNSPECIFIED', 'AUTO', 'ANY', 'NONE']).optional(),\n      allowedFunctionNames: z.array(z.string()).optional(),\n    })\n    .describe(\n      'Controls how the model uses the provided tools (function declarations). ' +\n        'With AUTO (Default) mode, the model decides whether to generate a ' +\n        'natural language response or suggest a function call based on the ' +\n        'prompt and context. With ANY, the model is constrained to always ' +\n        'predict a function call and guarantee function schema adherence. ' +\n        'With NONE, the model is prohibited from making function calls.'\n    )\n    .optional(),\n  responseModalities: z\n    .array(z.enum(['TEXT', 'IMAGE', 'AUDIO']))\n    .describe(\n      'The modalities to be used in response. Only supported for ' +\n        \"'gemini-2.0-flash-exp' model at present.\"\n    )\n    .optional(),\n  googleSearchRetrieval: z\n    .union([z.boolean(), z.object({}).passthrough()])\n    .describe(\n      'Retrieve public web data for grounding, powered by Google Search.'\n    )\n    .optional(),\n  temperature: z\n    .number()\n    .min(0)\n    .max(2)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n  topP: z\n    .number()\n    .min(0)\n    .max(1)\n    .describe(\n      GenerationCommonConfigDescriptions.topP + ' The default value is 0.95.'\n    )\n    .optional(),\n  thinkingConfig: z\n    .object({\n      includeThoughts: z\n        .boolean()\n        .describe(\n          'Indicates whether to include thoughts in the response.' +\n            'If true, thoughts are returned only if the model supports ' +\n            'thought and thoughts are available.'\n        )\n        .optional(),\n      thinkingBudget: z\n        .number()\n        .min(0)\n        .max(24576)\n        .describe(\n          'Indicates the thinking budget in tokens. 0 is DISABLED. ' +\n            '-1 is AUTOMATIC. The default values and allowed ranges are model ' +\n            'dependent. The thinking budget parameter gives the model guidance ' +\n            'on the number of thinking tokens it can use when generating a ' +\n            'response. A greater number of tokens is typically associated with ' +\n            'more detailed thinking, which is needed for solving more complex ' +\n            'tasks. '\n        )\n        .optional(),\n    })\n    .optional(),\n}).passthrough();\nexport type GeminiConfigSchemaType = typeof GeminiConfigSchema;\nexport type GeminiConfig = z.infer<GeminiConfigSchemaType>;\n\nexport const GeminiTtsConfigSchema = GeminiConfigSchema.extend({\n  speechConfig: z\n    .object({\n      voiceConfig: VoiceConfigSchema.optional(),\n      multiSpeakerVoiceConfig: z\n        .object({\n          speakerVoiceConfigs: z\n            .array(\n              z\n                .object({\n                  speaker: z.string().describe('Name of the speaker to use'),\n                  voiceConfig: VoiceConfigSchema,\n                })\n                .describe(\n                  'Configuration for a single speaker in a multi speaker setup'\n                )\n                .passthrough()\n            )\n            .describe('Configuration for all the enabled speaker voices'),\n        })\n        .describe('Configuration for multi-speaker setup')\n        .passthrough()\n        .optional(),\n    })\n    .describe('Speech generation config')\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiTtsConfigSchemaType = typeof GeminiTtsConfigSchema;\nexport type GeminiTtsConfig = z.infer<GeminiTtsConfigSchemaType>;\n\nexport const GemmaConfigSchema = GeminiConfigSchema.extend({\n  temperature: z\n    .number()\n    .min(0.0)\n    .max(1.0)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n}).passthrough();\nexport type GemmaConfigSchemaType = typeof GemmaConfigSchema;\nexport type GemmaConfig = z.infer<GemmaConfigSchemaType>;\n\n// This contains all the Gemini config schema types\ntype ConfigSchemaType =\n  | GeminiConfigSchemaType\n  | GeminiTtsConfigSchemaType\n  | GemmaConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = GeminiConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: 'no-tools',\n        output: ['text', 'json'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('gemini');\nconst GENERIC_TTS_MODEL = commonRef(\n  'gemini-tts',\n  {\n    supports: {\n      multiturn: false,\n      media: false,\n      tools: false,\n      toolChoice: false,\n      systemRole: false,\n      constrained: 'no-tools',\n    },\n  },\n  GeminiTtsConfigSchema\n);\nconst GENERIC_GEMMA_MODEL = commonRef(\n  'gemma-generic',\n  undefined,\n  GemmaConfigSchema\n);\n\nconst KNOWN_GEMINI_MODELS = {\n  'gemini-2.5-pro': commonRef('gemini-2.5-pro'),\n  'gemini-2.5-flash': commonRef('gemini-2.5-flash'),\n  'gemini-2.5-flash-lite': commonRef('gemini-2.5-flash-lite'),\n  'gemini-2.5-flash-image-preview': commonRef('gemini-2.5-flash-image-preview'),\n  'gemini-2.0-flash': commonRef('gemini-2.0-flash'),\n  'gemini-2.0-flash-preview-image-generation': commonRef(\n    'gemini-2.0-flash-preview-image-generation'\n  ),\n  'gemini-2.0-flash-lite': commonRef('gemini-2.0-flash-lite'),\n};\nexport type KnownGeminiModels = keyof typeof KNOWN_GEMINI_MODELS;\nexport type GeminiModelName = `gemini-${string}`;\nexport function isGeminiModelName(value: string): value is GeminiModelName {\n  return value.startsWith('gemini-') && !value.endsWith('-tts');\n}\n\nconst KNOWN_TTS_MODELS = {\n  'gemini-2.5-flash-preview-tts': commonRef(\n    'gemini-2.5-flash-preview-tts',\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  ),\n  'gemini-2.5-pro-preview-tts': commonRef(\n    'gemini-2.5-pro-preview-tts',\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  ),\n};\nexport type KnownTtsModels = keyof typeof KNOWN_TTS_MODELS;\nexport type TTSModelName = `gemini-${string}-tts`;\nexport function isTTSModelName(value: string): value is TTSModelName {\n  return value.startsWith('gemini-') && value.endsWith('-tts');\n}\n\nconst KNOWN_GEMMA_MODELS = {\n  'gemma-3-12b-it': commonRef('gemma-3-12b-it', undefined, GemmaConfigSchema),\n  'gemma-3-1b-it': commonRef('gemma-3-1b-it', undefined, GemmaConfigSchema),\n  'gemma-3-27b-it': commonRef('gemma-3-27b-it', undefined, GemmaConfigSchema),\n  'gemma-3-4b-it': commonRef('gemma-3-4b-it', undefined, GemmaConfigSchema),\n  'gemma-3n-e4b-it': commonRef('gemma-3n-e4b-it', undefined, GemmaConfigSchema),\n} as const;\nexport type KnownGemmaModels = keyof typeof KNOWN_GEMMA_MODELS;\nexport type GemmaModelName = `gemma-${string}`;\nexport function isGemmaModelName(value: string): value is GemmaModelName {\n  return value.startsWith('gemma-');\n}\n\nconst KNOWN_MODELS = {\n  ...KNOWN_GEMINI_MODELS,\n  ...KNOWN_TTS_MODELS,\n  ...KNOWN_GEMMA_MODELS,\n};\n\nexport function model(\n  version: string,\n  config: GeminiConfig | GeminiTtsConfig | GemmaConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n\n  if (isTTSModelName(name)) {\n    return modelRef({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GeminiTtsConfigSchema,\n      info: { ...GENERIC_TTS_MODEL.info },\n    });\n  }\n\n  if (isGemmaModelName(name)) {\n    return modelRef({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GemmaConfigSchema,\n      info: { ...GENERIC_GEMMA_MODEL.info },\n    });\n  }\n\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GeminiConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Gemini models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter((m) => m.supportedGenerationMethods.includes('generateContent'))\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return modelActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function defineKnownModels(ai: Genkit, options?: GoogleAIPluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\n\n/**\n * Defines a new GoogleAI Gemini model.\n */\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): ModelAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n  };\n\n  const middleware: ModelMiddleware[] = [];\n  if (ref.info?.supports?.media) {\n    // the gemini api doesn't support downloading media from http(s)\n    middleware.push(\n      downloadRequestMedia({\n        maxBytes: 1024 * 1024 * 10,\n        // don't downlaod files that have been uploaded using the Files API\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              [\n                'generativelanguage.googleapis.com',\n                'www.youtube.com',\n                'youtube.com',\n                'youtu.be',\n              ].includes(url.hostname)\n            )\n              return false;\n          } catch {}\n          return true;\n        },\n      })\n    );\n  }\n\n  return ai.defineModel(\n    {\n      apiVersion: 'v2',\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middleware,\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n\n      // Make a copy so that modifying the request will not produce side-effects\n      const messages = [...request.messages];\n      if (messages.length === 0) throw new Error('No messages provided.');\n\n      // Gemini does not support messages with role system and instead expects\n      // systemInstructions to be provided as a separate input. The first\n      // message detected with role=system will be used for systemInstructions.\n      let systemInstruction: GeminiMessage | undefined = undefined;\n      const systemMessage = messages.find((m) => m.role === 'system');\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = toGeminiSystemInstruction(systemMessage);\n      }\n\n      const tools: Tool[] = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(toGeminiTool),\n        });\n      }\n\n      const requestOptions: z.infer<ConfigSchemaType> = {\n        ...request.config,\n      };\n      const {\n        apiKey: apiKeyFromConfig,\n        safetySettings: safetySettingsFromConfig,\n        codeExecution: codeExecutionFromConfig,\n        version: versionFromConfig,\n        functionCallingConfig,\n        googleSearchRetrieval,\n        tools: toolsFromConfig,\n        ...restOfConfigOptions\n      } = requestOptions;\n\n      if (codeExecutionFromConfig) {\n        tools.push({\n          codeExecution:\n            codeExecutionFromConfig === true ? {} : codeExecutionFromConfig,\n        });\n      }\n\n      if (toolsFromConfig) {\n        tools.push(...(toolsFromConfig as any[]));\n      }\n\n      if (googleSearchRetrieval) {\n        tools.push({\n          googleSearch:\n            googleSearchRetrieval === true ? {} : googleSearchRetrieval,\n        } as GoogleSearchRetrievalTool);\n      }\n\n      let toolConfig: ToolConfig | undefined;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: toGeminiFunctionModeEnum(functionCallingConfig.mode),\n          },\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: toGeminiFunctionModeEnum(request.toolChoice),\n          },\n        };\n      }\n\n      // Cannot use tools with JSON mode\n      const jsonMode =\n        request.output?.format === 'json' ||\n        (request.output?.contentType === 'application/json' &&\n          tools.length === 0);\n\n      const generationConfig: GenerationConfig = {\n        ...restOfConfigOptions,\n        candidateCount: request.candidates || undefined,\n        responseMimeType: jsonMode ? 'application/json' : undefined,\n      };\n\n      if (request.output?.constrained && jsonMode) {\n        generationConfig.responseSchema = cleanSchema(request.output.schema);\n      }\n\n      const msg = toGeminiMessage(messages[messages.length - 1], ref);\n\n      let generateContentRequest: GenerateContentRequest = {\n        systemInstruction,\n        generationConfig,\n        tools: tools.length ? tools : undefined,\n        toolConfig,\n        safetySettings: safetySettingsFromConfig?.filter(\n          (setting) => setting.category !== 'HARM_CATEGORY_UNSPECIFIED'\n        ) as SafetySetting[],\n        contents: messages.map((message) => toGeminiMessage(message, ref)),\n      };\n\n      const modelVersion = versionFromConfig || extractVersion(ref);\n\n      const generateApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        requestOptions.apiKey\n      );\n\n      const callGemini = async () => {\n        let response: GenerateContentResponse;\n\n        if (streamingRequested) {\n          const result = await generateContentStream(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n\n          for await (const item of result.stream) {\n            item.candidates?.forEach((candidate) => {\n              const c = fromGeminiCandidate(candidate);\n              sendChunk({\n                index: c.index,\n                content: c.message.content,\n              });\n            });\n          }\n          response = await result.response;\n        } else {\n          response = await generateContent(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n\n        const candidates = response.candidates || [];\n        if (response.candidates?.['undefined']) {\n          candidates.push(response.candidates['undefined']);\n        }\n        if (!candidates.length) {\n          throw new GenkitError({\n            status: 'FAILED_PRECONDITION',\n            message: 'No valid candidates returned.',\n          });\n        }\n\n        const candidateData = candidates.map(fromGeminiCandidate) || [];\n\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...getBasicUsageStats(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens:\n              response.usageMetadata?.cachedContentTokenCount,\n          },\n        };\n      };\n\n      // If debugTraces is enabled, we wrap the actual model call with a span, add raw\n      // API params as for input.\n      return pluginOptions?.experimental_debugTraces\n        ? await runInNewSpan(\n            ai.registry,\n            {\n              metadata: {\n                name: streamingRequested ? 'sendMessageStream' : 'sendMessage',\n              },\n            },\n            async (metadata) => {\n              metadata.input = {\n                apiEndpoint: getGoogleAIUrl({\n                  resourcePath: '',\n                  clientOptions: clientOpt,\n                }),\n                cache: {},\n                model: modelVersion,\n                generateContentOptions: generateContentRequest,\n                parts: msg.parts,\n                options: clientOpt,\n              };\n              const response = await callGemini();\n              metadata.output = response.custom;\n              return response;\n            }\n          )\n        : await callGemini();\n    }\n  );\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2006, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/imagen.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  MediaPart,\n  MessageData,\n  modelActionMetadata,\n  z,\n  type Genkit,\n} from 'genkit';\nimport {\n  getBasicUsageStats,\n  modelRef,\n  type GenerateRequest,\n  type ModelAction,\n  type ModelInfo,\n  type ModelReference,\n} from 'genkit/model';\nimport { imagenPredict } from './client.js';\nimport type {\n  ClientOptions,\n  GoogleAIPluginOptions,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPrediction,\n  Model,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkApiKey,\n  checkModelName,\n  extractImagenImage,\n  extractText,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/image-generation#imagen-model\n */\nexport const ImagenConfigSchema = z\n  .object({\n    apiKey: z\n      .string()\n      .describe('Override the API key provided at plugin initialization.')\n      .optional(),\n\n    numberOfImages: z\n      .number()\n      .describe(\n        'The number of images to generate, from 1 to 4 (inclusive). The default is 1.'\n      )\n      .optional(),\n    aspectRatio: z\n      .enum(['1:1', '9:16', '16:9', '3:4', '4:3'])\n      .describe('Desired aspect ratio of the output image.')\n      .optional(),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .describe(\n        'Control if/how images of people will be generated by the model.'\n      )\n      .optional(),\n  })\n  .passthrough();\nexport type ImagenConfigSchemaType = typeof ImagenConfigSchema;\nexport type ImagenConfig = z.infer<ImagenConfigSchemaType>;\n\n// This contains all the schemas for imagen models.\ntype ConfigSchemaType = ImagenConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = ImagenConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\n// Allow all the capabilities for unknown future models\nconst GENERIC_MODEL = commonRef('imagen', {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: ['media'],\n  },\n});\n\nconst KNOWN_MODELS = {\n  'imagen-3.0-generate-002': commonRef('imagen-3.0-generate-002'),\n  'imagen-4.0-generate-preview-06-06': commonRef(\n    'imagen-4.0-generate-preview-06-06'\n  ),\n  'imagen-4.0-ultra-generate-preview-06-06': commonRef(\n    'imagen-4.0-ultra-generate-preview-06-06'\n  ),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\n\n// For conditional types in index.ts model()\nexport type ImagenModelName = `imagen-${string}`;\nexport function isImagenModelName(value?: string): value is ImagenModelName {\n  return !!value?.startsWith('imagen-');\n}\n\nexport function model(\n  version: string,\n  config: ImagenConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter(\n      (m) =>\n        m.supportedGenerationMethods.includes('predict') &&\n        isImagenModelName(modelName(m.name))\n    )\n    .filter((m) => !m.description || !m.description.includes('deprecated'))\n    .map((m) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function defineKnownModels(ai: Genkit, options?: GoogleAIPluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\n\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): ModelAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n  };\n\n  return ai.defineModel(\n    {\n      apiVersion: 'v2',\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const imagenPredictRequest: ImagenPredictRequest = {\n        instances: [\n          {\n            prompt: extractText(request),\n            image: extractImagenImage(request),\n          },\n        ],\n        parameters: toImagenParameters(request),\n      };\n\n      const predictApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        request.config?.apiKey\n      );\n\n      const response = await imagenPredict(\n        predictApiKey,\n        extractVersion(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      const message: MessageData = {\n        role: 'model',\n        content: response.predictions.map(fromImagenPrediction),\n      };\n\n      return {\n        finishReason: 'stop',\n        message,\n        usage: getBasicUsageStats(request.messages, message),\n        custom: response,\n      };\n    }\n  );\n}\n\nfunction fromImagenPrediction(p: ImagenPrediction): MediaPart {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    media: {\n      url: `data:${mimeType};base64,${b64data}`,\n      contentType: mimeType,\n    },\n  };\n}\n\nfunction toImagenParameters(\n  request: GenerateRequest<typeof ImagenConfigSchema>\n): ImagenParameters {\n  const out = {\n    sampleCount: request.config?.numberOfImages ?? 1,\n    ...request?.config,\n  };\n\n  for (const k in out) {\n    if (!out[k]) delete out[k];\n  }\n\n  // This is not part of the request parameters sent to the endpoint\n  // It's pulled out and used separately\n  delete out.apiKey;\n\n  return out;\n}\n\nexport const TEST_ONLY = {\n  toImagenParameters,\n  fromImagenPrediction,\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2211, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/veo.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  GenerateResponseData,\n  Operation,\n  modelActionMetadata,\n  z,\n  type Genkit,\n} from 'genkit';\nimport {\n  BackgroundModelAction,\n  modelRef,\n  type GenerateRequest,\n  type ModelInfo,\n  type ModelReference,\n} from 'genkit/model';\nimport { veoCheckOperation, veoPredict } from './client.js';\nimport {\n  ClientOptions,\n  GoogleAIPluginOptions,\n  Model,\n  VeoOperation,\n  VeoParameters,\n  VeoPredictRequest,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkModelName,\n  extractText,\n  extractVeoImage,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/video\n */\nexport const VeoConfigSchema = z\n  .object({\n    // NOTE: Documentation notes numberOfVideos parameter to pick the number of\n    // output videos, but this setting does not seem to work\n    negativePrompt: z.string().optional(),\n    aspectRatio: z\n      .enum(['9:16', '16:9'])\n      .describe('Desired aspect ratio of the output video.')\n      .optional(),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .describe(\n        'Control if/how images of people will be generated by the model.'\n      )\n      .optional(),\n    durationSeconds: z\n      .number()\n      .step(1)\n      .min(5)\n      .max(8)\n      .describe('Length of each output video in seconds, between 5 and 8.')\n      .optional(),\n    enhancePrompt: z\n      .boolean()\n      .describe('Enable or disable the prompt rewriter. Enabled by default.')\n      .optional(),\n  })\n  .passthrough();\nexport type VeoConfigSchemaType = typeof VeoConfigSchema;\nexport type VeoConfig = z.infer<VeoConfigSchemaType>;\n\n// This contains all the Veo config schema types\ntype ConfigSchemaType = VeoConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = VeoConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info:\n      info ??\n      ({\n        supports: {\n          media: true,\n          multiturn: false,\n          tools: false,\n          systemRole: false,\n          output: ['media'],\n          longRunning: true,\n        },\n      } as ModelInfo), // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\n\nconst GENERIC_MODEL = commonRef('veo');\n\nconst KNOWN_MODELS = {\n  'veo-3.0-generate-preview': commonRef('veo-3.0-generate-preview'),\n  'veo-3.0-fast-generate-preview': commonRef('veo-3.0-fast-generate-preview'),\n  'veo-2.0-generate-001': commonRef('veo-2.0-generate-001'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\nexport type VeoModelName = `veo-${string}`;\nexport function isVeoModelName(value?: string): value is VeoModelName {\n  return !!value?.startsWith('veo-');\n}\n\nexport function model(\n  version: string,\n  config: VeoConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Veo models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter(\n        (m) =>\n          m.supportedGenerationMethods.includes('predictLongRunning') &&\n          isVeoModelName(modelName(m.name))\n      )\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return modelActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function defineKnownModels(ai: Genkit, options?: GoogleAIPluginOptions) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, options);\n  }\n}\n\n/**\n * Defines a new GoogleAI Veo model.\n */\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): BackgroundModelAction<VeoConfigSchemaType> {\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n  };\n\n  return ai.defineBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const apiKey = calculateApiKey(pluginOptions?.apiKey, undefined);\n      const veoPredictRequest: VeoPredictRequest = {\n        instances: [\n          {\n            prompt: extractText(request),\n            image: extractVeoImage(request),\n          },\n        ],\n        parameters: toVeoParameters(request),\n      };\n\n      const response = await veoPredict(\n        apiKey,\n        extractVersion(ref),\n        veoPredictRequest,\n        clientOptions\n      );\n\n      return fromVeoOperation(response);\n    },\n    async check(operation) {\n      const apiKey = calculateApiKey(pluginOptions?.apiKey, undefined);\n      const response = await veoCheckOperation(\n        apiKey,\n        operation.id,\n        clientOptions\n      );\n      return fromVeoOperation(response);\n    },\n  });\n}\n\nfunction toVeoParameters(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoParameters {\n  const out = {\n    ...request?.config,\n  };\n\n  for (const k in out) {\n    // undefined is handled by JSON.stringify\n    // false is needed so we can set enhancePrompt to false\n    if (out[k] === null) delete out[k];\n  }\n\n  // This is not part of the request parameters sent to the endpoint\n  // It's pulled out and used separately\n  delete out.apiKey;\n\n  // This was used to help us figure out which model. We no longer need\n  // it here.\n  delete out.version;\n\n  return out;\n}\n\nfunction fromVeoOperation(\n  apiOp: VeoOperation\n): Operation<GenerateResponseData> {\n  const res = { id: apiOp.name } as Operation<GenerateResponseData>;\n  if (apiOp.done !== undefined) {\n    res.done = apiOp.done;\n  }\n\n  if (apiOp.error) {\n    res.error = { message: apiOp.error.message };\n  }\n\n  if (\n    apiOp.response &&\n    apiOp.response.generateVideoResponse &&\n    apiOp.response.generateVideoResponse.generatedSamples\n  ) {\n    res.output = {\n      finishReason: 'stop',\n      raw: apiOp.response,\n      message: {\n        role: 'model',\n        content: apiOp.response.generateVideoResponse.generatedSamples.map(\n          (s) => {\n            return {\n              media: {\n                url: s.video.uri,\n              },\n            };\n          }\n        ),\n      },\n    };\n  }\n\n  return res;\n}\n\nexport const TEST_ONLY = {\n  toVeoParameters,\n  fromVeoOperation,\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2411, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/googleai/index.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  EmbedderReference,\n  Genkit,\n  ModelReference,\n  z,\n} from 'genkit';\nimport { logger } from 'genkit/logging';\nimport { GenkitPlugin, genkitPlugin } from 'genkit/plugin';\nimport { ActionType } from 'genkit/registry';\nimport { extractErrMsg } from '../common/utils.js';\nimport { listModels } from './client.js';\nimport { GoogleAIPluginOptions } from './types.js';\nimport { calculateApiKey } from './utils.js';\n\n// These are namespaced because they all intentionally have\n// functions of the same name with the same arguments.\n// (All exports from these files are used here)\nimport * as embedder from './embedder.js';\nimport * as gemini from './gemini.js';\nimport * as imagen from './imagen.js';\nimport * as veo from './veo.js';\n\nexport { type EmbeddingConfig } from './embedder.js';\nexport { type GeminiConfig, type GeminiTtsConfig } from './gemini.js';\nexport { type ImagenConfig } from './imagen.js';\nexport { type GoogleAIPluginOptions };\n\nasync function initializer(ai: Genkit, options?: GoogleAIPluginOptions) {\n  imagen.defineKnownModels(ai, options);\n  gemini.defineKnownModels(ai, options);\n  embedder.defineKnownModels(ai, options);\n  veo.defineKnownModels(ai, options);\n}\n\nasync function resolver(\n  ai: Genkit,\n  actionType: ActionType,\n  actionName: string,\n  options: GoogleAIPluginOptions\n) {\n  switch (actionType) {\n    case 'model':\n      if (veo.isVeoModelName(actionName)) {\n        // no-op (not gemini)\n      } else if (imagen.isImagenModelName(actionName)) {\n        imagen.defineModel(ai, actionName, options);\n      } else {\n        // gemini, tts, gemma, unknown models\n        gemini.defineModel(ai, actionName, options);\n      }\n      break;\n    case 'background-model':\n      if (veo.isVeoModelName(actionName)) {\n        veo.defineModel(ai, actionName, options);\n      }\n      break;\n    case 'embedder':\n      embedder.defineEmbedder(ai, actionName, options);\n      break;\n    default:\n    // no-op\n  }\n}\n\nasync function listActions(\n  options?: GoogleAIPluginOptions\n): Promise<ActionMetadata[]> {\n  try {\n    const apiKey = calculateApiKey(options?.apiKey, undefined);\n    const allModels = await listModels(apiKey, {\n      baseUrl: options?.baseUrl,\n      apiVersion: options?.apiVersion,\n    });\n\n    return [\n      ...gemini.listActions(allModels),\n      ...imagen.listActions(allModels),\n      ...veo.listActions(allModels),\n      ...embedder.listActions(allModels),\n    ];\n  } catch (e: unknown) {\n    logger.error(extractErrMsg(e));\n    return [];\n  }\n}\n\n/**\n * Google Gemini Developer API plugin.\n */\nexport function googleAIPlugin(options?: GoogleAIPluginOptions): GenkitPlugin {\n  let listActionsCache;\n  return genkitPlugin(\n    'googleai',\n    async (ai: Genkit) => await initializer(ai, options),\n    async (ai: Genkit, actionType: ActionType, actionName: string) =>\n      await resolver(ai, actionType, actionName, options || {}),\n    async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    }\n  );\n}\n\nexport type GoogleAIPlugin = {\n  (pluginOptions?: GoogleAIPluginOptions): GenkitPlugin;\n  model(\n    name: gemini.KnownGemmaModels | (gemini.GemmaModelName & {}),\n    config: gemini.GemmaConfig\n  ): ModelReference<gemini.GemmaConfigSchemaType>;\n  model(\n    name: gemini.KnownTtsModels | (gemini.TTSModelName & {}),\n    config: gemini.GeminiTtsConfig\n  ): ModelReference<gemini.GeminiTtsConfigSchemaType>;\n  model(\n    name: gemini.KnownGeminiModels | (gemini.GeminiModelName & {}),\n    config?: gemini.GeminiConfig\n  ): ModelReference<gemini.GeminiConfigSchemaType>;\n  model(\n    name: imagen.KnownModels | (imagen.ImagenModelName & {}),\n    config?: imagen.ImagenConfig\n  ): ModelReference<imagen.ImagenConfigSchemaType>;\n  model(\n    name: veo.KnownModels | (veo.VeoModelName & {}),\n    config?: veo.VeoConfig\n  ): ModelReference<veo.VeoConfigSchemaType>;\n  model(name: string, config?: any): ModelReference<z.ZodTypeAny>;\n\n  embedder(\n    name: string,\n    config?: embedder.EmbeddingConfig\n  ): EmbedderReference<embedder.EmbeddingConfigSchemaType>;\n};\n\n/**\n * Google Gemini Developer API plugin.\n */\nexport const googleAI = googleAIPlugin as GoogleAIPlugin;\n(googleAI as any).model = (\n  name: string,\n  config?: any\n): ModelReference<z.ZodTypeAny> => {\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  // gemma, tts, gemini and unknown model families.\n  return gemini.model(name, config);\n};\ngoogleAI.embedder = (\n  name: string,\n  config?: embedder.EmbeddingConfig\n): EmbedderReference<embedder.EmbeddingConfigSchemaType> => {\n  return embedder.model(name, config);\n};\n\nexport default googleAI;\n"],"names":["import_utils"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,mBAAA,CAAA;AAAA,SAAA,kBAAA;IAAA,SAAA,IAAA;IAAA,UAAA,IAAA;IAAA,gBAAA,IAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAuBA,IAAA,iBAAuB;AACvB,IAAA,gBAA2C;AAE3C,IAAA,eAA8B;AAC9B,IAAA,gBAA2B;AAE3B,IAAAA,gBAAgC;AAKhC,IAAA,WAA0B;AAC1B,IAAA,SAAwB;AACxB,IAAA,SAAwB;AACxB,IAAA,MAAqB;AAOrB,eAAe,YAAY,EAAA,EAAY,OAAA,EAAiC;IACtE,OAAO,iBAAA,CAAkB,IAAI,OAAO;IACpC,OAAO,iBAAA,CAAkB,IAAI,OAAO;IACpC,SAAS,iBAAA,CAAkB,IAAI,OAAO;IACtC,IAAI,iBAAA,CAAkB,IAAI,OAAO;AACnC;AAEA,eAAe,SACb,EAAA,EACA,UAAA,EACA,UAAA,EACA,OAAA,EACA;IACA,OAAQ,YAAY;QAClB,KAAK;YACH,IAAI,IAAI,cAAA,CAAe,UAAU,GAAG,CAEpC,OAAA,IAAW,OAAO,iBAAA,CAAkB,UAAU,GAAG;gBAC/C,OAAO,WAAA,CAAY,IAAI,YAAY,OAAO;YAC5C,OAAO;gBAEL,OAAO,WAAA,CAAY,IAAI,YAAY,OAAO;YAC5C;YACA;QACF,KAAK;YACH,IAAI,IAAI,cAAA,CAAe,UAAU,GAAG;gBAClC,IAAI,WAAA,CAAY,IAAI,YAAY,OAAO;YACzC;YACA;QACF,KAAK;YACH,SAAS,cAAA,CAAe,IAAI,YAAY,OAAO;YAC/C;QACF;IAEF;AACF;AAEA,eAAe,YACb,OAAA,EAC2B;IAC3B,IAAI;QACF,MAAM,SAAA,CAAA,GAAS,cAAA,eAAA,EAAgB,SAAS,QAAQ,KAAA,CAAS;QACzD,MAAM,YAAY,MAAA,CAAA,GAAM,cAAA,UAAA,EAAW,QAAQ;YACzC,SAAS,SAAS;YAClB,YAAY,SAAS;QACvB,CAAC;QAED,OAAO;eACF,OAAO,WAAA,CAAY,SAAS;eAC5B,OAAO,WAAA,CAAY,SAAS;eAC5B,IAAI,WAAA,CAAY,SAAS;eACzB,SAAS,WAAA,CAAY,SAAS;SACnC;IACF,EAAA,OAAS,GAAY;QACnB,eAAA,MAAA,CAAO,KAAA,CAAA,CAAA,GAAM,aAAA,aAAA,EAAc,CAAC,CAAC;QAC7B,OAAO,CAAC,CAAA;IACV;AACF;AAKO,SAAS,eAAe,OAAA,EAA+C;IAC5E,IAAI;IACJ,OAAA,CAAA,GAAO,cAAA,YAAA,EACL,YACA,OAAO,KAAe,MAAM,YAAY,IAAI,OAAO,GACnD,OAAO,IAAY,YAAwB,aACzC,MAAM,SAAS,IAAI,YAAY,YAAY,WAAW,CAAC,CAAC,GAC1D,YAAY;QACV,IAAI,iBAAkB,CAAA,OAAO;QAC7B,mBAAmB,MAAM,YAAY,OAAO;QAC5C,OAAO;IACT;AAEJ;AAmCO,MAAM,WAAW;AACvB,SAAiB,KAAA,GAAQ,CACxB,MACA,WACiC;IACjC,IAAI,IAAI,cAAA,CAAe,IAAI,GAAG;QAC5B,OAAO,IAAI,KAAA,CAAM,MAAM,MAAM;IAC/B;IACA,IAAI,OAAO,iBAAA,CAAkB,IAAI,GAAG;QAClC,OAAO,OAAO,KAAA,CAAM,MAAM,MAAM;IAClC;IAEA,OAAO,OAAO,KAAA,CAAM,MAAM,MAAM;AAClC;AACA,SAAS,QAAA,GAAW,CAClB,MACA,WAC0D;IAC1D,OAAO,SAAS,KAAA,CAAM,MAAM,MAAM;AACpC;AAEA,IAAO,mBAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2536, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError } from 'genkit';\nimport { GoogleAuth } from 'google-auth-library';\nimport type {\n  ClientOptions,\n  ExpressClientOptions,\n  GlobalClientOptions,\n  RegionalClientOptions,\n  VertexPluginOptions,\n} from './types.js';\n\nexport {\n  checkModelName,\n  checkSupportedMimeType,\n  cleanSchema,\n  extractMedia,\n  extractMimeType,\n  extractText,\n  extractVersion,\n  modelName,\n} from '../common/utils.js';\n\nconst CLOUD_PLATFORM_OAUTH_SCOPE =\n  'https://www.googleapis.com/auth/cloud-platform';\n\nfunction parseFirebaseProjectId(): string | undefined {\n  if (!process.env.FIREBASE_CONFIG) return undefined;\n  try {\n    return JSON.parse(process.env.FIREBASE_CONFIG).projectId as string;\n  } catch {\n    return undefined;\n  }\n}\n\nlet __mockDerivedOptions: ClientOptions | undefined = undefined;\nfunction setMockDerivedOptions(options: ClientOptions | undefined): void {\n  __mockDerivedOptions = options;\n}\nexport const TEST_ONLY = { setMockDerivedOptions };\n\nexport async function getDerivedOptions(\n  options?: VertexPluginOptions,\n  AuthClass: typeof GoogleAuth = GoogleAuth // Injectable testing\n): Promise<ClientOptions> {\n  if (__mockDerivedOptions) {\n    return Promise.resolve(__mockDerivedOptions);\n  }\n\n  // Figure out the type of preferred options if possible\n  // The order of the if statements is important.\n  if (options?.location == 'global') {\n    return await getGlobalDerivedOptions(AuthClass, options);\n  } else if (options?.location) {\n    return await getRegionalDerivedOptions(AuthClass, options);\n  } else if (options?.apiKey !== undefined) {\n    // apiKey = false still indicates apiKey expectation\n    return getExpressDerivedOptions(options);\n  }\n\n  // If we got here then we're relying on environment variables.\n  // Try regional first, it's the most common usage.\n  try {\n    const regionalOptions = await getRegionalDerivedOptions(AuthClass, options);\n    return regionalOptions;\n  } catch (e: unknown) {\n    /* no-op - try global next */\n  }\n  try {\n    const globalOptions = await getGlobalDerivedOptions(AuthClass, options);\n    return globalOptions;\n  } catch (e: unknown) {\n    /* no-op - try express last */\n  }\n  try {\n    const expressOptions = getExpressDerivedOptions(options);\n    return expressOptions;\n  } catch (e: unknown) {\n    /* no-op */\n  }\n\n  // We did not have enough information in the options or in environment variables\n  // to properly determine client options.\n  throw new GenkitError({\n    status: 'INVALID_ARGUMENT',\n    message:\n      'Unable to determine client options. Please set either apiKey or projectId and location',\n  });\n}\n\nasync function getGlobalDerivedOptions(\n  AuthClass: typeof GoogleAuth,\n  options?: VertexPluginOptions\n): Promise<GlobalClientOptions> {\n  let authOptions = options?.googleAuth;\n  let authClient: GoogleAuth;\n  const providedProjectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId,\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId,\n      }\n    );\n  }\n\n  const projectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    (await authClient.getProjectId());\n\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n\n  const clientOpt: GlobalClientOptions = {\n    kind: 'global',\n    location: 'global',\n    projectId,\n    authClient,\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n\n  return clientOpt;\n}\n\nfunction getExpressDerivedOptions(\n  options?: VertexPluginOptions\n): ExpressClientOptions {\n  const apiKey = checkApiKey(options?.apiKey);\n  return {\n    kind: 'express',\n    apiKey,\n  };\n}\n\nasync function getRegionalDerivedOptions(\n  AuthClass: typeof GoogleAuth,\n  options?: VertexPluginOptions\n): Promise<RegionalClientOptions> {\n  let authOptions = options?.googleAuth;\n  let authClient: GoogleAuth;\n  const providedProjectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId,\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId,\n      }\n    );\n  }\n\n  const projectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    (await authClient.getProjectId());\n  const location =\n    options?.location || process.env.GCLOUD_LOCATION || 'us-central1';\n\n  if (!location) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'location' configuration. Please set the 'GCLOUD_LOCATION' environment variable or explicitly pass 'location' into genkit config.`\n    );\n  }\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n\n  const clientOpt: RegionalClientOptions = {\n    kind: 'regional',\n    location,\n    projectId,\n    authClient,\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n  return clientOpt;\n}\n\n/**\n * Retrieves an API key from environment variables.\n *\n * @returns The API key as a string, or `undefined` if none of the specified\n *          environment variables are set.\n */\nexport function getApiKeyFromEnvVar(): string | undefined {\n  return (\n    process.env.VERTEX_API_KEY ||\n    process.env.GOOGLE_API_KEY ||\n    process.env.GOOGLE_GENAI_API_KEY\n  );\n}\n\nexport const MISSING_API_KEY_ERROR = new GenkitError({\n  status: 'FAILED_PRECONDITION',\n  message:\n    'Please pass in the API key or set the VERTEX_API_KEY or GOOGLE_API_KEY environment variable.\\n' +\n    'For more details see https://firebase.google.com/docs/genkit/plugins/google-genai',\n});\n\nexport const API_KEY_FALSE_ERROR = new GenkitError({\n  status: 'INVALID_ARGUMENT',\n  message:\n    'VertexAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.',\n});\n\nexport const NOT_SUPPORTED_IN_EXPRESS_ERROR = new GenkitError({\n  status: 'PERMISSION_DENIED',\n  message:\n    'This method or model is not supported in Vertex AI Express Mode.\\n' +\n    'For more details see https://cloud.google.com/vertex-ai/generative-ai/docs/start/express-mode/vertex-ai-express-mode-api-reference',\n});\n\n/**\n * Checks and retrieves an API key based on the provided argument and environment variables.\n *\n * - If `pluginApiKey` is a non-empty string, it's used as the API key.\n * - If `pluginApiKey` is `undefined` or an empty string, it attempts to fetch the API key from environment\n * - If `pluginApiKey` is `false`, key retrieval from the environment is skipped, and the function\n *   will return `undefined`. This mode indicates that the API key is expected to be provided\n *   at a later stage or in a different context.\n *\n * @param pluginApiKey - An optional API key string, `undefined` to check the environment, or `false` to bypass all checks in this function.\n * @returns The resolved API key as a string, or `undefined` if `pluginApiKey` is `false`.\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if `pluginApiKey` is not `false` and no API key\n *   can be found either in the `pluginApiKey` argument or from the environment.\n */\nexport function checkApiKey(\n  pluginApiKey: string | false | undefined\n): string | undefined {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  // If pluginApiKey is false, then we don't throw because we are waiting for\n  // the apiKey passed into the individual call\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/**\n * Calculates and returns the effective API key based on multiple potential sources.\n * The order of precedence for determining the API key is:\n * 1. `requestApiKey` (if provided)\n * 2. `pluginApiKey` (if provided and not `false`)\n * 3. Environment variable (if `pluginApiKey` is not `false` and `pluginApiKey` is not provided)\n *\n * @param pluginApiKey - The apiKey value provided during plugin initialization.\n * @param requestApiKey - The apiKey provided to an individual generate call.\n * @returns The resolved API key as a string.\n * @throws {Error} API_KEY_FALSE_ERROR - Thrown if `pluginApiKey` is `false` and `requestApiKey` is not provided\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if no API key can be resolved from any source\n */\nexport function calculateApiKey(\n  pluginApiKey: string | false | undefined,\n  requestApiKey: string | undefined\n): string {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  apiKey = requestApiKey || apiKey;\n\n  if (pluginApiKey === false && !requestApiKey) {\n    throw API_KEY_FALSE_ERROR;\n  }\n\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/** Vertex Express Mode lets you try a *subset* of Vertex AI features */\nexport function checkSupportedResourceMethod(params: {\n  clientOptions: ClientOptions;\n  resourcePath?: string;\n  resourceMethod?: string;\n}) {\n  if (params.resourcePath == '') {\n    // This is how we get a base url for metadata\n    return;\n  }\n\n  const supportedExpressMethods = [\n    'countTokens',\n    'generateContent',\n    'streamGenerateContent',\n  ];\n\n  if (\n    params.clientOptions.kind === 'express' &&\n    (!supportedExpressMethods.includes(params.resourceMethod ?? '') ||\n      params.resourcePath?.includes('endpoints/'))\n  ) {\n    throw NOT_SUPPORTED_IN_EXPRESS_ERROR;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2789, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/client.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GoogleAuth } from 'google-auth-library';\nimport {\n  extractErrMsg,\n  getGenkitClientHeader,\n  processStream,\n} from '../common/utils.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbedContentResponse,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ListModelsResponse,\n  LyriaPredictRequest,\n  LyriaPredictResponse,\n  Model,\n  VeoOperation,\n  VeoOperationRequest,\n  VeoPredictRequest,\n} from './types.js';\nimport { calculateApiKey, checkSupportedResourceMethod } from './utils.js';\n\nexport async function listModels(\n  clientOptions: ClientOptions\n): Promise<Model[]> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: false,\n    resourcePath: 'publishers/google/models',\n    clientOptions,\n  });\n  const fetchOptions = await getFetchOptions({\n    method: 'GET',\n    clientOptions,\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = (await response.json()) as ListModelsResponse;\n  return modelResponse.publisherModels;\n}\n\nexport async function generateContent(\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions: ClientOptions\n): Promise<GenerateContentResponse> {\n  let url: string;\n  if (model.includes('endpoints/')) {\n    // Tuned model\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith('projects/'),\n      resourcePath: model,\n      resourceMethod: 'generateContent',\n      clientOptions,\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: 'generateContent',\n      clientOptions,\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n\n  const responseJson = (await response.json()) as GenerateContentResponse;\n  return responseJson;\n}\n\nexport async function generateContentStream(\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions: ClientOptions\n): Promise<GenerateContentStreamResult> {\n  let url: string;\n  if (model.includes('endpoints/')) {\n    // Tuned model\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith('projects/'),\n      resourcePath: model,\n      resourceMethod: 'streamGenerateContent',\n      clientOptions,\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: 'streamGenerateContent',\n      clientOptions,\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return processStream(response);\n}\n\nasync function internalPredict(\n  model: string,\n  body: string,\n  clientOptions: ClientOptions\n): Promise<Response> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'predict',\n    clientOptions,\n  });\n\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body,\n  });\n\n  return await makeRequest(url, fetchOptions);\n}\n\nexport async function embedContent(\n  model: string,\n  embedContentRequest: EmbedContentRequest,\n  clientOptions: ClientOptions\n): Promise<EmbedContentResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(embedContentRequest),\n    clientOptions\n  );\n  return response.json() as Promise<EmbedContentResponse>;\n}\n\nexport async function imagenPredict(\n  model: string,\n  imagenPredictRequest: ImagenPredictRequest,\n  clientOptions: ClientOptions\n): Promise<ImagenPredictResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(imagenPredictRequest),\n    clientOptions\n  );\n  return response.json() as Promise<ImagenPredictResponse>;\n}\n\nexport async function lyriaPredict(\n  model: string,\n  lyriaPredictRequest: LyriaPredictRequest,\n  clientOptions: ClientOptions\n): Promise<LyriaPredictResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(lyriaPredictRequest),\n    clientOptions\n  );\n  return response.json() as Promise<LyriaPredictResponse>;\n}\n\nexport async function veoPredict(\n  model: string,\n  veoPredictRequest: VeoPredictRequest,\n  clientOptions: ClientOptions\n): Promise<VeoOperation> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'predictLongRunning',\n    clientOptions,\n  });\n\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\nexport async function veoCheckOperation(\n  model: string,\n  veoOperationRequest: VeoOperationRequest,\n  clientOptions: ClientOptions\n): Promise<VeoOperation> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'fetchPredictOperation',\n    clientOptions,\n  });\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(veoOperationRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\nexport function getVertexAIUrl(params: {\n  includeProjectAndLocation: boolean; // False for listModels, true for most others\n  resourcePath: string;\n  resourceMethod?: string;\n  queryParams?: string;\n  clientOptions: ClientOptions;\n}): string {\n  checkSupportedResourceMethod(params);\n\n  const DEFAULT_API_VERSION = 'v1beta1';\n  const API_BASE_PATH = 'aiplatform.googleapis.com';\n\n  let basePath: string;\n\n  if (params.clientOptions.kind == 'regional') {\n    basePath = `${params.clientOptions.location}-${API_BASE_PATH}`;\n  } else {\n    basePath = API_BASE_PATH;\n  }\n\n  let resourcePath = params.resourcePath;\n  if (\n    params.clientOptions.kind != 'express' &&\n    params.includeProjectAndLocation\n  ) {\n    const parent = `projects/${params.clientOptions.projectId}/locations/${params.clientOptions.location}`;\n    resourcePath = `${parent}/${params.resourcePath}`;\n  }\n\n  let url = `https://${basePath}/${DEFAULT_API_VERSION}/${resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n\n  let joiner = '?';\n  if (params.queryParams) {\n    url += `${joiner}${params.queryParams}`;\n    joiner = '&';\n  }\n  if (params.resourceMethod === 'streamGenerateContent') {\n    url += `${joiner}alt=sse`;\n    joiner = '&';\n  }\n  return url;\n}\n\nasync function getFetchOptions(params: {\n  method: 'POST' | 'GET';\n  body?: string;\n  clientOptions: ClientOptions;\n}) {\n  const fetchOptions: RequestInit = {\n    method: params.method,\n    headers: await getHeaders(params.clientOptions),\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\n\nfunction getAbortSignal(clientOptions: ClientOptions): AbortSignal | undefined {\n  const hasTimeout = (clientOptions.timeout ?? -1) >= 0;\n  if (clientOptions.signal !== undefined || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener('abort', () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return undefined;\n}\n\nasync function getHeaders(clientOptions: ClientOptions): Promise<HeadersInit> {\n  if (clientOptions.kind == 'express') {\n    const headers: HeadersInit = {\n      'x-goog-api-key': calculateApiKey(clientOptions.apiKey, undefined),\n      'Content-Type': 'application/json',\n      'X-Goog-Api-Client': getGenkitClientHeader(),\n      'User-Agent': getGenkitClientHeader(),\n    };\n    return headers;\n  } else {\n    const token = await getToken(clientOptions.authClient);\n    const headers: HeadersInit = {\n      Authorization: `Bearer ${token}`,\n      'x-goog-user-project': clientOptions.projectId,\n      'Content-Type': 'application/json',\n      'X-Goog-Api-Client': getGenkitClientHeader(),\n      'User-Agent': getGenkitClientHeader(),\n    };\n    if (clientOptions.apiKey) {\n      headers['x-goog-api-key'] = clientOptions.apiKey;\n    }\n    return headers;\n  }\n}\n\nasync function getToken(authClient: GoogleAuth): Promise<string> {\n  const CREDENTIAL_ERROR_MESSAGE =\n    '\\nUnable to authenticate your request\\\n        \\nDepending on your run time environment, you can get authentication by\\\n        \\n- if in local instance or cloud shell: `!gcloud auth login`\\\n        \\n- if in Colab:\\\n        \\n    -`from google.colab import auth`\\\n        \\n    -`auth.authenticate_user()`\\\n        \\n- if in service account or other: please follow guidance in https://cloud.google.com/docs/authentication';\n  const token = await authClient.getAccessToken().catch((e) => {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE, e);\n  });\n  if (!token) {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE);\n  }\n  return token;\n}\n\nasync function makeRequest(\n  url: string,\n  fetchOptions: RequestInit\n): Promise<Response> {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n        // Not JSON or expected format, use the raw text\n      }\n      throw new Error(\n        `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`\n      );\n    }\n    return response;\n  } catch (e: unknown) {\n    console.error(e);\n    throw new Error(`Failed to fetch from ${url}: ${extractErrMsg(e)}`);\n  }\n}\n\nexport const TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest,\n};\n"],"names":["import_utils"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3087, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GoogleAuth, GoogleAuthOptions } from 'google-auth-library';\nimport {\n  CitationMetadata,\n  CodeExecutionTool,\n  Content,\n  FunctionCallingMode,\n  FunctionDeclarationsTool,\n  GenerateContentCandidate,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  GoogleSearchRetrieval,\n  GoogleSearchRetrievalTool,\n  GroundingMetadata,\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  RetrievalTool,\n  TaskType,\n  TaskTypeSchema,\n  Tool,\n  ToolConfig,\n  isCodeExecutionTool,\n  isFunctionDeclarationsTool,\n  isGoogleSearchRetrievalTool,\n  isObject,\n  isRetrievalTool,\n} from '../common/types.js';\n\n// This makes it easier to import all types from one place\nexport {\n  FunctionCallingMode,\n  HarmBlockThreshold,\n  HarmCategory,\n  TaskTypeSchema,\n  isCodeExecutionTool,\n  isFunctionDeclarationsTool,\n  isGoogleSearchRetrievalTool,\n  isObject,\n  isRetrievalTool,\n  type CitationMetadata,\n  type CodeExecutionTool,\n  type Content,\n  type FunctionDeclarationsTool,\n  type GenerateContentCandidate,\n  type GenerateContentRequest,\n  type GenerateContentResponse,\n  type GenerateContentStreamResult,\n  type GoogleSearchRetrieval,\n  type GoogleSearchRetrievalTool,\n  type GroundingMetadata,\n  type ImagenInstance,\n  type ImagenParameters,\n  type ImagenPredictRequest,\n  type ImagenPredictResponse,\n  type ImagenPrediction,\n  type RetrievalTool,\n  type Tool,\n  type ToolConfig,\n};\n\n/** Options for Vertex AI plugin configuration */\nexport interface VertexPluginOptions {\n  /** The Vertex API key for express mode */\n  apiKey?: string | false;\n  /** The Google Cloud project id to call. */\n  projectId?: string;\n  /** The Google Cloud region to call. */\n  location?: string;\n  /** Provide custom authentication configuration for connecting to Vertex AI. */\n  googleAuth?: GoogleAuthOptions;\n  /** Enables additional debug traces (e.g. raw model API call details). */\n  experimental_debugTraces?: boolean;\n}\n\ninterface BaseClientOptions {\n  /** timeout in milli seconds. time out value needs to be non negative. */\n  timeout?: number;\n  signal?: AbortSignal;\n}\n\nexport interface RegionalClientOptions extends BaseClientOptions {\n  kind: 'regional';\n  location: string;\n  projectId: string;\n  authClient: GoogleAuth;\n  apiKey?: string; // In addition to regular auth\n}\n\nexport interface GlobalClientOptions extends BaseClientOptions {\n  kind: 'global';\n  location: 'global';\n  projectId: string;\n  authClient: GoogleAuth;\n  apiKey?: string; // In addition to regular auth\n}\n\nexport interface ExpressClientOptions extends BaseClientOptions {\n  kind: 'express';\n  apiKey: string | false | undefined; // Instead of regular auth\n}\n\n/** Resolved options for use with the client */\nexport type ClientOptions =\n  | RegionalClientOptions\n  | GlobalClientOptions\n  | ExpressClientOptions;\n\n/**\n * Request options params.\n */\nexport interface RequestOptions {\n  /** an apiKey to use for this request if applicable */\n  apiKey?: string | false | undefined;\n  /** timeout in milli seconds. time out value needs to be non negative. */\n  timeout?: number;\n  /**\n   * Version of API endpoint to call (e.g. \"v1\" or \"v1beta\"). If not specified,\n   * defaults to 'v1beta'.\n   */\n  apiVersion?: string;\n  /**\n   * Value for x-goog-api-client header to set on the API request. This is\n   * intended for wrapper SDKs to set additional SDK identifiers for the\n   * backend.\n   */\n  apiClient?: string;\n  /**\n   * Value for custom HTTP headers to set on the HTTP request.\n   */\n  customHeaders?: Headers;\n}\n\n// Vertex AI  model definition\nexport interface Model {\n  name: string;\n  launchStage: string;\n}\n\n// Vertex AI list models response\nexport interface ListModelsResponse {\n  publisherModels: Model[];\n}\n\n// https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/text-embeddings-api#request_body\ninterface TextEmbeddingInstance {\n  task_type?: TaskType;\n  content: string;\n  title?: string;\n}\n\n// https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/multimodal-embeddings-api#request_body\ninterface MultimodalEmbeddingInstance {\n  text?: string;\n  image?: {\n    // Union field can only be one of the following:\n    bytesBase64Encoded?: string;\n    gcsUri?: string;\n    // End of list of possible types for union field.\n    mimeType?: string;\n  };\n  video?: {\n    // Union field can only be one of the following:\n    bytesBase64Encoded?: string;\n    gcsUri?: string;\n    // End of list of possible types for union field.\n    videoSegmentConfig?: {\n      startOffsetSec: number;\n      endOffsetSec: number;\n      intervalSec: number;\n    };\n  };\n  parameters?: {\n    dimension: number;\n  };\n}\n\nexport declare type EmbeddingInstance =\n  | TextEmbeddingInstance\n  | MultimodalEmbeddingInstance;\n\nexport declare interface TextEmbeddingPrediction {\n  embeddings: {\n    statistics: {\n      truncated: boolean;\n      token_count: number;\n    };\n    values: number[];\n  };\n}\n\nexport declare interface VideoEmbedding {\n  startOffsetSec: number;\n  endOffsetSec: number;\n  embedding: number[];\n}\n\nexport declare interface MultimodalEmbeddingPrediction {\n  textEmbedding?: number[];\n  imageEmbedding?: number[];\n  videoEmbeddings?: VideoEmbedding[];\n}\n\nexport function isMultimodalEmbeddingPrediction(\n  value: unknown\n): value is MultimodalEmbeddingPrediction {\n  if (!isObject(value)) {\n    return false;\n  }\n  if (!value.textEmbedding && !value.imageEmbedding && !value.videoEmbeddings) {\n    return false;\n  }\n  if (value.textEmbedding && !Array.isArray(value.textEmbedding)) {\n    return false;\n  }\n  if (value.imageEmbedding && !Array.isArray(value.imageEmbedding)) {\n    return false;\n  }\n  if (value.videoEmbeddings && !Array.isArray(value.videoEmbeddings)) {\n    return false;\n  }\n  if (value.videoEmbeddings) {\n    for (const emb of value.videoEmbeddings as Array<unknown>) {\n      if (!isObject(emb)) {\n        return false;\n      }\n      if (!emb.embedding || !Array.isArray(emb.embedding)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport declare type EmbeddingPrediction =\n  | TextEmbeddingPrediction\n  | MultimodalEmbeddingPrediction;\n\nexport declare interface EmbedContentRequest {\n  instances: EmbeddingInstance[];\n  parameters: EmbedContentConfig;\n}\n\nexport declare interface EmbedContentResponse {\n  predictions: EmbeddingPrediction[];\n}\n\n/** Optional parameters for the embed content method. */\nexport declare interface EmbedContentConfig {\n  /** Type of task for which the embedding will be used. */\n  taskType?: string;\n  /** Title for the text. Only applicable when TaskType is\n      `RETRIEVAL_DOCUMENT`.\n       */\n  title?: string;\n  /** Reduced dimension for the output embedding. If set,\n      excessive values in the output embedding are truncated from the end.\n      Supported by newer models since 2024 only. You cannot set this value if\n      using the earlier model (`models/embedding-001`).\n       */\n  outputDimensionality?: number;\n  /** The MIME type of the input. */\n  mimeType?: string;\n  /** Vertex API only. Whether to silently truncate inputs longer than\n      the max sequence length. If this option is set to false, oversized inputs\n      will lead to an INVALID_ARGUMENT error, similar to other text APIs.\n       */\n  autoTruncate?: boolean;\n}\n\nexport declare type EmbeddingResult = {\n  embedding: number[];\n  metadata?: Record<string, unknown>;\n};\n\nexport declare interface VeoMedia {\n  bytesBase64Encoded?: string;\n  gcsUri?: string;\n  mimeType?: string;\n}\n\nexport declare interface VeoInstance {\n  prompt: string;\n  image?: VeoMedia;\n  lastFrame?: VeoMedia;\n  video?: VeoMedia;\n}\n\nexport declare interface VeoParameters {\n  aspectRatio?: string;\n  durationSeconds?: number;\n  enhancePrompt?: boolean;\n  generateAudio?: boolean;\n  negativePrompt?: string;\n  personGeneration?: string;\n  resolution?: string; // Veo 3\n  sampleCount?: number;\n  seed?: number;\n  storageUri?: string;\n}\n\nexport declare interface VeoPredictRequest {\n  instances: VeoInstance[];\n  parameters: VeoParameters;\n}\n\nexport declare interface Operation {\n  name: string;\n  done?: boolean;\n  error?: {\n    code: number;\n    message: string;\n    details?: unknown;\n  };\n}\n\nexport declare interface VeoOperation extends Operation {\n  response?: {\n    raiMediaFilteredCount?: number;\n    videos: VeoMedia[];\n  };\n}\n\nexport declare interface VeoOperationRequest {\n  operationName: string;\n}\n\nexport declare interface LyriaParameters {\n  sampleCount?: number;\n}\n\nexport declare interface LyriaPredictRequest {\n  instances: LyriaInstance[];\n  parameters: LyriaParameters;\n}\n\nexport declare interface LyriaPredictResponse {\n  predictions: LyriaPrediction[];\n}\n\nexport declare interface LyriaPrediction {\n  bytesBase64Encoded: string; // Base64 encoded Wav string\n  mimeType: string; // audio/wav\n}\n\nexport declare interface LyriaInstance {\n  prompt: string;\n  negativePrompt?: string;\n  seed?: number;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,qBAAA,IAAA,aAAA,mBAAA;IAAA,oBAAA,IAAA,aAAA,kBAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,gBAAA,IAAA,aAAA,cAAA;IAAA,qBAAA,IAAA,aAAA,mBAAA;IAAA,4BAAA,IAAA,aAAA,0BAAA;IAAA,6BAAA,IAAA,aAAA,2BAAA;IAAA,iCAAA,IAAA;IAAA,UAAA,IAAA,aAAA,QAAA;IAAA,iBAAA,IAAA,aAAA,eAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAiBA,IAAA,eA8BO;AAgLA,SAAS,gCACd,KAAA,EACwC;IACxC,IAAI,CAAA,CAAA,GAAC,aAAA,QAAA,EAAS,KAAK,GAAG;QACpB,OAAO;IACT;IACA,IAAI,CAAC,MAAM,aAAA,IAAiB,CAAC,MAAM,cAAA,IAAkB,CAAC,MAAM,eAAA,EAAiB;QAC3E,OAAO;IACT;IACA,IAAI,MAAM,aAAA,IAAiB,CAAC,MAAM,OAAA,CAAQ,MAAM,aAAa,GAAG;QAC9D,OAAO;IACT;IACA,IAAI,MAAM,cAAA,IAAkB,CAAC,MAAM,OAAA,CAAQ,MAAM,cAAc,GAAG;QAChE,OAAO;IACT;IACA,IAAI,MAAM,eAAA,IAAmB,CAAC,MAAM,OAAA,CAAQ,MAAM,eAAe,GAAG;QAClE,OAAO;IACT;IACA,IAAI,MAAM,eAAA,EAAiB;QACzB,KAAA,MAAW,OAAO,MAAM,eAAA,CAAmC;YACzD,IAAI,CAAA,CAAA,GAAC,aAAA,QAAA,EAAS,GAAG,GAAG;gBAClB,OAAO;YACT;YACA,IAAI,CAAC,IAAI,SAAA,IAAa,CAAC,MAAM,OAAA,CAAQ,IAAI,SAAS,GAAG;gBACnD,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3171, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/embedder.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z, type Document, type Genkit } from 'genkit';\nimport {\n  EmbedderInfo,\n  embedderRef,\n  type EmbedderAction,\n  type EmbedderReference,\n} from 'genkit/embedder';\nimport { embedContent } from './client.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbeddingInstance,\n  EmbeddingPrediction,\n  EmbeddingResult,\n  TaskTypeSchema,\n  VertexPluginOptions,\n  isMultimodalEmbeddingPrediction,\n  isObject,\n} from './types.js';\nimport { checkModelName, extractVersion } from './utils.js';\n\nexport const EmbeddingConfigSchema = z\n  .object({\n    /**\n     * The `task_type` parameter is defined as the intended downstream application\n     * to help the model produce better quality embeddings.\n     **/\n    taskType: TaskTypeSchema.optional(),\n    title: z.string().optional(),\n    location: z.string().optional(),\n    version: z.string().optional(),\n    /**\n     * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n     * By default, the model generates embeddings with 768 dimensions.\n     * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n     **/\n    outputDimensionality: z.number().min(1).optional(),\n    /**\n     * For newly released embedders this parameter provides a hint for the proper\n     * way to call the embedder. (Multimodal embedders have a different request\n     * structure than non-multimodal embedders).\n     * For well-known embedders, this value will be ignored since we will already\n     * know if it's multimodal or not.\n     */\n    multimodal: z.boolean().optional(),\n  })\n  .passthrough();\nexport type EmbeddingConfigSchemaType = typeof EmbeddingConfigSchema;\nexport type EmbeddingConfig = z.infer<EmbeddingConfigSchemaType>;\n\n// for commonRef\ntype ConfigSchemaType = EmbeddingConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: EmbedderInfo,\n  configSchema: ConfigSchemaType = EmbeddingConfigSchema\n): EmbedderReference<ConfigSchemaType> {\n  return embedderRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: ['text'],\n      },\n    },\n  });\n}\n\nconst GENERIC_TEXT_MODEL = commonRef('text', {\n  dimensions: 3072,\n  supports: { input: ['text'] },\n});\nconst GENERIC_MULTIMODAL_MODEL = commonRef('multimodal', {\n  dimensions: 768,\n  supports: { input: ['text', 'image', 'video'] },\n});\n\nexport const KNOWN_MODELS = {\n  'text-embedding-005': commonRef('text-embedding-005'),\n  'text-multilingual-embedding-002': commonRef(\n    'text-multilingual-embedding-002'\n  ),\n  'multimodalembedding@001': commonRef('multimodalembedding@001', {\n    dimensions: 768,\n    supports: { input: ['text', 'image', 'video'] },\n  }),\n  'gemini-embedding-001': commonRef('gemini-embedding-001', {\n    dimensions: 3072,\n    supports: { input: ['text'] },\n  }),\n} as const;\n\nexport function model(\n  version: string,\n  config: EmbeddingConfig = {}\n): EmbedderReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return embedderRef({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...KNOWN_MODELS[name].info,\n      },\n    });\n  }\n  if (config.multimodal) {\n    // Generic multimodal embedder format\n    return embedderRef({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...GENERIC_MULTIMODAL_MODEL.info,\n      },\n    });\n  }\n  // Generic text-only embedder format\n  return embedderRef({\n    name: `vertexai/${name}`,\n    configSchema: EmbeddingConfigSchema,\n    config,\n    info: {\n      ...GENERIC_TEXT_MODEL.info,\n    },\n  });\n}\n\nexport function defineKnownModels(\n  ai: Genkit,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineEmbedder(ai, name, clientOptions, pluginOptions);\n  }\n}\n\nexport function defineEmbedder(\n  ai: Genkit,\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): EmbedderAction<any> {\n  const ref = model(name);\n\n  return ai.defineEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info!,\n    },\n    async (input, options?: EmbeddingConfig) => {\n      const embedContentRequest: EmbedContentRequest = {\n        instances: input.map((doc: Document) =>\n          toEmbeddingInstance(ref, doc, options)\n        ),\n        parameters: { outputDimensionality: options?.outputDimensionality },\n      };\n\n      const response = await embedContent(\n        extractVersion(ref),\n        embedContentRequest,\n        clientOptions\n      );\n\n      return {\n        embeddings: response.predictions\n          .map(toEmbeddingResult)\n          .reduce((accumulator, value) => {\n            return accumulator.concat(value);\n          }, []),\n      };\n    }\n  );\n}\n\nfunction toEmbeddingInstance(\n  embedder: EmbedderReference<ConfigSchemaType>,\n  doc: Document,\n  options?: EmbeddingConfig\n): EmbeddingInstance {\n  let instance: EmbeddingInstance;\n  if (\n    isMultiModalEmbedder(embedder) ||\n    embedder.config?.multimodal ||\n    options?.multimodal\n  ) {\n    instance = {};\n    if (doc.text) {\n      instance.text = doc.text;\n    }\n    for (var media of doc.media) {\n      if (\n        isObject(media) &&\n        typeof media.url === 'string' &&\n        typeof media.contentType === 'string'\n      ) {\n        if (media.contentType?.startsWith('image/')) {\n          if (media.url.startsWith('http') || media.url.startsWith('gs://')) {\n            instance.image = {\n              gcsUri: media.url,\n              mimeType: media.contentType,\n            };\n          } else {\n            instance.image = {\n              bytesBase64Encoded: media.url,\n              mimeType: media.contentType,\n            };\n          }\n        } else if (media.contentType.startsWith('video/')) {\n          if (media.url.startsWith('http') || media.url.startsWith('gs://')) {\n            instance.video = {\n              gcsUri: media.url,\n            };\n          } else {\n            instance.video = {\n              bytesBase64Encoded: media.url,\n            };\n          }\n          if (\n            instance.video &&\n            doc.metadata &&\n            doc.metadata.videoSegmentConfig\n          ) {\n            instance.video.videoSegmentConfig = doc.metadata.videoSegmentConfig;\n          }\n        } else {\n          throw new Error(`Unsupported contentType: '${media.contentType}`);\n        }\n      } else {\n        // It needs to be a {url:string, contentType:string} object.\n        throw new Error('Invalid media specified.');\n      }\n    }\n  } else {\n    // Text only embedder\n    instance = {\n      content: doc.text,\n      task_type: options?.taskType,\n      title: options?.title,\n    };\n  }\n  return instance;\n}\n\n/**\n * Converts an `EmbeddingPrediction` object to an array of `EmbeddingResult` objects.\n *\n * There will only be multiple EmbeddingResult objects in the array if it is a\n * multimodal embedding prediction for a video.\n * A single video gets automatically broken into chunks and an embedding is\n * returned for each chunk. The metadata identifies which chunk of the video\n * it is for.\n *\n * @param prediction The input `EmbeddingPrediction` object.\n * @returns An array of `EmbeddingResult` objects, each representing a different embedding.\n */\nfunction toEmbeddingResult(prediction: EmbeddingPrediction): EmbeddingResult[] {\n  if (isMultimodalEmbeddingPrediction(prediction)) {\n    const eArray: EmbeddingResult[] = [];\n    if (prediction.imageEmbedding?.length) {\n      const imageResult: EmbeddingResult = {\n        embedding: prediction.imageEmbedding,\n        metadata: { embedType: 'imageEmbedding' },\n      };\n      eArray.push(imageResult);\n    }\n    if (prediction.textEmbedding?.length) {\n      const textResult: EmbeddingResult = {\n        embedding: prediction.textEmbedding,\n        metadata: { embedType: 'textEmbedding' },\n      };\n      eArray.push(textResult);\n    }\n    if (prediction.videoEmbeddings?.length) {\n      for (const ve of prediction.videoEmbeddings) {\n        if (ve.embedding?.length) {\n          const { embedding, ...metadata } = ve;\n          (metadata as Record<string, unknown>).embedType = 'videoEmbedding';\n          const videoResult: EmbeddingResult = {\n            embedding,\n            metadata,\n          };\n          eArray.push(videoResult);\n        }\n      }\n    }\n    return eArray;\n  } else {\n    // Text-only embedding\n    return [\n      {\n        embedding: prediction.embeddings.values,\n      },\n    ];\n  }\n}\n\nfunction isMultiModalEmbedder(\n  embedder: EmbedderReference<ConfigSchemaType>\n): boolean {\n  if (embedder.config?.multimodal) {\n    return true;\n  }\n  const input = embedder.info?.supports?.input || '';\n  return (input.includes('text') && input.includes('image')) || false;\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3458, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  GenerateRequest,\n  GenerateResponseData,\n  GenkitError,\n  MediaPart,\n  Operation,\n  z,\n} from 'genkit';\nimport { CandidateData, getBasicUsageStats } from 'genkit/model';\nimport {\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  SafetySetting,\n} from '../common/types.js';\nimport { SafetySettingsSchema } from './gemini.js';\nimport { ImagenConfigSchemaType } from './imagen.js';\nimport { LyriaConfigSchemaType } from './lyria.js';\nimport {\n  LyriaInstance,\n  LyriaParameters,\n  LyriaPredictRequest,\n  LyriaPredictResponse,\n  LyriaPrediction,\n  VeoInstance,\n  VeoMedia,\n  VeoOperation,\n  VeoOperationRequest,\n  VeoPredictRequest,\n} from './types.js';\nimport {\n  checkSupportedMimeType,\n  extractMedia,\n  extractMimeType,\n  extractText,\n} from './utils.js';\nimport { VeoConfigSchemaType } from './veo.js';\n\nexport function toGeminiSafetySettings(\n  genkitSettings?: z.infer<typeof SafetySettingsSchema>[]\n): SafetySetting[] | undefined {\n  if (!genkitSettings) return undefined;\n  return genkitSettings.map((s) => {\n    return {\n      category: s.category as HarmCategory,\n      threshold: s.threshold as HarmBlockThreshold,\n    };\n  });\n}\n\nexport function toGeminiLabels(\n  labels?: Record<string, string>\n): Record<string, string> | undefined {\n  if (!labels) {\n    return undefined;\n  }\n  const keys = Object.keys(labels);\n  const newLabels: Record<string, string> = {};\n  for (const key of keys) {\n    const value = labels[key];\n    if (!key) {\n      continue;\n    }\n    newLabels[key] = value;\n  }\n\n  if (Object.keys(newLabels).length == 0) {\n    return undefined;\n  }\n  return newLabels;\n}\n\nexport function toImagenPredictRequest(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenPredictRequest {\n  return {\n    instances: toImagenInstances(request),\n    parameters: toImagenParameters(request),\n  };\n}\n\nfunction toImagenInstances(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenInstance[] {\n  let instance: ImagenInstance = {\n    prompt: extractText(request),\n  };\n\n  const imageMedia = extractMedia(request, {\n    metadataType: 'image',\n    isDefault: true,\n  });\n  if (imageMedia) {\n    const image = imageMedia.url.split(',')[1];\n    instance.image = {\n      bytesBase64Encoded: image,\n    };\n  }\n\n  const maskMedia = extractMedia(request, { metadataType: 'mask' });\n  if (maskMedia) {\n    const mask = maskMedia.url.split(',')[1];\n    instance.mask = {\n      image: {\n        bytesBase64Encoded: mask,\n      },\n    };\n  }\n\n  return [instance];\n}\n\nfunction toImagenParameters(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenParameters {\n  const params = {\n    sampleCount: request.candidates ?? 1,\n    ...request?.config,\n  };\n\n  for (const k in params) {\n    if (!params[k]) delete params[k];\n  }\n\n  return params;\n}\n\nfunction fromImagenPrediction(p: ImagenPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\n/**\n *\n * @param response The response to convert\n * @param request The request (for usage stats)\n * @returns The converted response\n */\nexport function fromImagenResponse(\n  response: ImagenPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates = response.predictions.map(fromImagenPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toLyriaPredictRequest(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaPredictRequest {\n  return {\n    instances: toLyriaInstances(request),\n    parameters: toLyriaParameters(request),\n  };\n}\n\nfunction toLyriaInstances(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaInstance[] {\n  let config = { ...request.config };\n  delete config.sampleCount; // Sample count goes in parameters, the rest go in instances\n  return [\n    {\n      prompt: extractText(request),\n      ...config,\n    },\n  ];\n}\n\nfunction toLyriaParameters(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaParameters {\n  return {\n    sampleCount: request.config?.sampleCount || 1,\n  };\n}\n\nfunction fromLyriaPrediction(p: LyriaPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\nexport function fromLyriaResponse(\n  response: LyriaPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates: CandidateData[] =\n    response.predictions.map(fromLyriaPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toVeoPredictRequest(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoPredictRequest {\n  return {\n    instances: toVeoInstances(request),\n    parameters: { ...request.config },\n  };\n}\n\nfunction toVeoInstances(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoInstance[] {\n  let instance: VeoInstance = {\n    prompt: extractText(request),\n  };\n  const supportedImageTypes = ['image/jpeg', 'image/png'];\n  const supportedVideoTypes = ['video/mp4'];\n\n  const imageMedia = extractMedia(request, { metadataType: 'image' });\n  if (imageMedia) {\n    checkSupportedMimeType(imageMedia, supportedImageTypes);\n    instance.image = toVeoMedia(imageMedia);\n  }\n\n  const lastFrameMedia = extractMedia(request, { metadataType: 'lastFrame' });\n  if (lastFrameMedia) {\n    checkSupportedMimeType(lastFrameMedia, supportedImageTypes);\n    instance.lastFrame = toVeoMedia(lastFrameMedia);\n  }\n\n  const videoMedia = extractMedia(request, { metadataType: 'video' });\n  if (videoMedia) {\n    checkSupportedMimeType(videoMedia, supportedVideoTypes);\n    instance.video = toVeoMedia(videoMedia);\n  }\n  return [instance];\n}\n\nexport function toVeoMedia(media: MediaPart['media']): VeoMedia {\n  let mimeType = media.contentType;\n  if (!mimeType) {\n    mimeType = extractMimeType(media.url);\n    if (!mimeType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: 'Content type is required.',\n      });\n    }\n  }\n  if (media.url.startsWith('data:')) {\n    return {\n      bytesBase64Encoded: media.url?.split(',')[1],\n      mimeType,\n    };\n  } else if (media.url.startsWith('gs://')) {\n    return {\n      gcsUri: media.url,\n      mimeType,\n    };\n  } else if (media.url.startsWith('http')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message:\n        'Veo does not support http(s) URIs. Please specify a Cloud Storage URI.',\n    });\n  } else {\n    // Assume it's a non-prefixed data url\n    return {\n      bytesBase64Encoded: media.url,\n      mimeType,\n    };\n  }\n}\n\nexport function fromVeoOperation(\n  fromOp: VeoOperation\n): Operation<GenerateResponseData> {\n  const toOp: Operation<GenerateResponseData> = { id: fromOp.name };\n  if (fromOp.done !== undefined) {\n    toOp.done = fromOp.done;\n  }\n  if (fromOp.error) {\n    toOp.error = { message: fromOp.error.message };\n  }\n\n  if (fromOp.response) {\n    toOp.output = {\n      finishReason: 'stop',\n      raw: fromOp.response,\n      message: {\n        role: 'model',\n        content: fromOp.response.videos.map((veoMedia) => {\n          if (veoMedia.bytesBase64Encoded) {\n            return {\n              media: {\n                url: `data:${veoMedia.mimeType}:base64,${veoMedia.bytesBase64Encoded}`,\n                contentType: veoMedia.mimeType,\n              },\n            };\n          }\n\n          return {\n            media: {\n              url: veoMedia.gcsUri ?? '',\n              contentType: veoMedia.mimeType,\n            },\n          };\n        }),\n      },\n    };\n  }\n\n  return toOp;\n}\n\nexport function toVeoModel(op: Operation<GenerateResponseData>): string {\n  return op.id.substring(\n    op.id.indexOf('models/') + 7,\n    op.id.indexOf('/operations/')\n  );\n}\n\nexport function toVeoOperationRequest(\n  op: Operation<GenerateResponseData>\n): VeoOperationRequest {\n  return {\n    operationName: op.id,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3801, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/gemini.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  Genkit,\n  GenkitError,\n  modelActionMetadata,\n  z,\n} from 'genkit';\nimport {\n  GenerationCommonConfigDescriptions,\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelMiddleware,\n  ModelReference,\n  getBasicUsageStats,\n  modelRef,\n} from 'genkit/model';\nimport { downloadRequestMedia } from 'genkit/model/middleware';\nimport { runInNewSpan } from 'genkit/tracing';\nimport {\n  fromGeminiCandidate,\n  toGeminiFunctionModeEnum,\n  toGeminiMessage,\n  toGeminiSystemInstruction,\n  toGeminiTool,\n} from '../common/converters.js';\nimport {\n  generateContent,\n  generateContentStream,\n  getVertexAIUrl,\n} from './client.js';\nimport { toGeminiLabels, toGeminiSafetySettings } from './converters.js';\nimport {\n  ClientOptions,\n  Content,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GoogleSearchRetrieval,\n  GoogleSearchRetrievalTool,\n  Model,\n  Tool,\n  ToolConfig,\n  VertexPluginOptions,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkModelName,\n  cleanSchema,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\nexport const SafetySettingsSchema = z.object({\n  category: z.enum([\n    /** The harm category is unspecified. */\n    'HARM_CATEGORY_UNSPECIFIED',\n    /** The harm category is hate speech. */\n    'HARM_CATEGORY_HATE_SPEECH',\n    /** The harm category is dangerous content. */\n    'HARM_CATEGORY_DANGEROUS_CONTENT',\n    /** The harm category is harassment. */\n    'HARM_CATEGORY_HARASSMENT',\n    /** The harm category is sexually explicit content. */\n    'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  ]),\n  threshold: z.enum([\n    'BLOCK_LOW_AND_ABOVE',\n    'BLOCK_MEDIUM_AND_ABOVE',\n    'BLOCK_ONLY_HIGH',\n    'BLOCK_NONE',\n  ]),\n});\n\nconst VertexRetrievalSchema = z.object({\n  datastore: z\n    .object({\n      projectId: z.string().describe('Google Cloud Project ID.').optional(),\n      location: z\n        .string()\n        .describe('Google Cloud region e.g. us-central1.')\n        .optional(),\n      dataStoreId: z\n        .string()\n        .describe(\n          'The data store id, when project id and location are provided as ' +\n            'separate options. Alternatively, the full path to the data ' +\n            'store should be provided in the form: \"projects/{project}/' +\n            'locations/{location}/collections/default_collection/dataStores/{data_store}\".'\n        ),\n    })\n    .describe('Vertex AI Search data store details'),\n  disableAttribution: z\n    .boolean()\n    .describe(\n      'Disable using the search data in detecting grounding attribution. This ' +\n        'does not affect how the result is given to the model for generation.'\n    )\n    .optional(),\n});\n\nconst GoogleSearchRetrievalSchema = z.object({\n  disableAttribution: z\n    .boolean()\n    .describe(\n      'Disable using the search data in detecting grounding attribution. This ' +\n        'does not affect how the result is given to the model for generation.'\n    )\n    .optional(),\n});\n\n/**\n * Zod schema of Gemini model options.\n * Please refer to: https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#generationconfig, for further information.\n */\nexport const GeminiConfigSchema = GenerationCommonConfigSchema.extend({\n  apiKey: z\n    .string()\n    .describe('Overrides the plugin-configured API key, if specified.')\n    .optional(),\n  labels: z\n    .record(z.string())\n    .optional()\n    .describe('Key-value labels to attach to the request for cost tracking.'),\n  temperature: z\n    .number()\n    .min(0.0)\n    .max(2.0)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n  topP: z\n    .number()\n    .min(0)\n    .max(1.0)\n    .describe(\n      GenerationCommonConfigDescriptions.topP + ' The default value is 0.95.'\n    )\n    .optional(),\n  location: z\n    .string()\n    .describe('Google Cloud region e.g. us-central1.')\n    .optional(),\n\n  /**\n   * Safety filter settings. See: https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters#configurable-filters\n   *\n   * E.g.\n   *\n   * ```js\n   * config: {\n   *   safetySettings: [\n   *     {\n   *       category: 'HARM_CATEGORY_HATE_SPEECH',\n   *       threshold: 'BLOCK_LOW_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n   *       threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_HARASSMENT',\n   *       threshold: 'BLOCK_ONLY_HIGH',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n   *       threshold: 'BLOCK_NONE',\n   *     },\n   *   ],\n   * }\n   * ```\n   */\n  safetySettings: z\n    .array(SafetySettingsSchema)\n    .describe(\n      'Adjust how likely you are to see responses that could be harmful. ' +\n        'Content is blocked based on the probability that it is harmful.'\n    )\n    .optional(),\n\n  /**\n   * Vertex retrieval options.\n   *\n   * E.g.\n   *\n   * ```js\n   *   config: {\n   *     vertexRetrieval: {\n   *       datastore: {\n   *         projectId: 'your-cloud-project',\n   *         location: 'us-central1',\n   *         collection: 'your-collection',\n   *       },\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  vertexRetrieval: VertexRetrievalSchema.describe(\n    'Retrieve from Vertex AI Search data store for grounding ' +\n      'generative responses.'\n  ).optional(),\n\n  /**\n   * Google Search retrieval options.\n   *\n   * ```js\n   *   config: {\n   *     googleSearchRetrieval: {\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  googleSearchRetrieval: GoogleSearchRetrievalSchema.describe(\n    'Retrieve public web data for grounding, powered by Google Search.'\n  ).optional(),\n\n  /**\n   * Function calling options.\n   *\n   * E.g. forced tool call:\n   *\n   * ```js\n   *   config: {\n   *     functionCallingConfig: {\n   *       mode: 'ANY',\n   *     }\n   *   }\n   * ```\n   */\n  functionCallingConfig: z\n    .object({\n      mode: z.enum(['MODE_UNSPECIFIED', 'AUTO', 'ANY', 'NONE']).optional(),\n      allowedFunctionNames: z.array(z.string()).optional(),\n    })\n    .describe(\n      'Controls how the model uses the provided tools (function declarations). ' +\n        'With AUTO (Default) mode, the model decides whether to generate a ' +\n        'natural language response or suggest a function call based on the ' +\n        'prompt and context. With ANY, the model is constrained to always ' +\n        'predict a function call and guarantee function schema adherence. ' +\n        'With NONE, the model is prohibited from making function calls.'\n    )\n    .optional(),\n  thinkingConfig: z\n    .object({\n      includeThoughts: z\n        .boolean()\n        .describe(\n          'Indicates whether to include thoughts in the response.' +\n            'If true, thoughts are returned only if the model supports ' +\n            'thought and thoughts are available.'\n        )\n        .optional(),\n      thinkingBudget: z\n        .number()\n        .min(0)\n        .max(24576)\n        .describe(\n          'Indicates the thinking budget in tokens. 0 is DISABLED. ' +\n            '-1 is AUTOMATIC. The default values and allowed ranges are model ' +\n            'dependent. The thinking budget parameter gives the model guidance ' +\n            'on the number of thinking tokens it can use when generating a ' +\n            'response. A greater number of tokens is typically associated with ' +\n            'more detailed thinking, which is needed for solving more complex ' +\n            'tasks. '\n        )\n        .optional(),\n    })\n    .optional(),\n}).passthrough();\nexport type GeminiConfigSchemaType = typeof GeminiConfigSchema;\n/**\n * Gemini model configuration options.\n *\n * E.g.\n * ```js\n *   config: {\n *     temperature: 0.9,\n *     maxOutputTokens: 300,\n *     safetySettings: [\n *       {\n *         category: 'HARM_CATEGORY_HATE_SPEECH',\n *         threshold: 'BLOCK_LOW_AND_ABOVE',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n *         threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_HARASSMENT',\n *         threshold: 'BLOCK_ONLY_HIGH',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n *         threshold: 'BLOCK_NONE',\n *       },\n *     ],\n *     functionCallingConfig: {\n *       mode: 'ANY',\n *     }\n *   }\n * ```\n */\nexport type GeminiConfig = z.infer<GeminiConfigSchemaType>;\n\n// This contains all the Gemini config schema types\ntype ConfigSchemaType = GeminiConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = GeminiConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: 'no-tools',\n      },\n    },\n  });\n}\n\nexport const GENERIC_MODEL = commonRef('gemini');\n\nexport const KNOWN_MODELS = {\n  'gemini-2.5-flash-lite': commonRef('gemini-2.5-flash-lite'),\n  'gemini-2.5-pro': commonRef('gemini-2.5-pro'),\n  'gemini-2.5-flash': commonRef('gemini-2.5-flash'),\n  'gemini-2.0-flash-001': commonRef('gemini-2.0-flash-001'),\n  'gemini-2.0-flash': commonRef('gemini-2.0-flash'),\n  'gemini-2.0-flash-lite': commonRef('gemini-2.0-flash-lite'),\n  'gemini-2.0-flash-lite-001': commonRef('gemini-2.0-flash-lite-001'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS;\nexport type GeminiModelName = `gemini-${string}`;\nexport function isGeminiModelName(value?: string): value is GeminiModelName {\n  return !!value?.startsWith('gemini-') && !value.includes('embedding');\n}\n\nexport function model(\n  version: string,\n  options: GeminiConfig = {}\n): ModelReference<typeof GeminiConfigSchema> {\n  const name = checkModelName(version);\n\n  return modelRef({\n    name: `vertexai/${name}`,\n    config: options,\n    configSchema: GeminiConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  const KNOWN_DECOMISSIONED_MODELS = [\n    'gemini-pro-vision',\n    'gemini-pro',\n    'gemini-ultra',\n    'gemini-ultra-vision',\n  ];\n\n  return models\n    .filter(\n      (m) =>\n        isGeminiModelName(modelName(m.name)) &&\n        !KNOWN_DECOMISSIONED_MODELS.includes(modelName(m.name) || '')\n    )\n    .map((m) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function defineKnownModels(\n  ai: Genkit,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\n\n/**\n * Define a Vertex AI Gemini model.\n */\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n  const middlewares: ModelMiddleware[] = [];\n  if (ref.info?.supports?.media) {\n    // the gemini api doesn't support downloading media from http(s)\n    middlewares.push(\n      downloadRequestMedia({\n        maxBytes: 1024 * 1024 * 20,\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              ['www.youtube.com', 'youtube.com', 'youtu.be'].includes(\n                url.hostname\n              )\n            )\n              return false;\n          } catch {}\n          return true;\n        },\n      })\n    );\n  }\n\n  return ai.defineModel(\n    {\n      apiVersion: 'v2',\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middlewares,\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      let clientOpt = { ...clientOptions, signal: abortSignal };\n\n      // Make a copy of messages to avoid side-effects\n      const messages = structuredClone(request.messages);\n      if (messages.length === 0) throw new Error('No messages provided.');\n\n      // Handle system instructions separately\n      let systemInstruction: Content | undefined = undefined;\n      const systemMessage = messages.find((m) => m.role === 'system');\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = toGeminiSystemInstruction(systemMessage);\n      }\n\n      const requestConfig = { ...request.config };\n\n      const {\n        apiKey: apiKeyFromConfig,\n        functionCallingConfig,\n        version: versionFromConfig,\n        googleSearchRetrieval,\n        tools: toolsFromConfig,\n        vertexRetrieval,\n        location,\n        safetySettings,\n        labels: labelsFromConfig,\n        ...restOfConfig\n      } = requestConfig;\n\n      if (\n        location &&\n        clientOptions.kind != 'express' &&\n        clientOptions.location != location\n      ) {\n        // Override the location if it's specified in the request\n        if (location == 'global') {\n          clientOpt = {\n            kind: 'global',\n            location: 'global',\n            projectId: clientOptions.projectId,\n            authClient: clientOptions.authClient,\n            apiKey: clientOptions.apiKey,\n            signal: abortSignal,\n          };\n        } else {\n          clientOpt = {\n            kind: 'regional',\n            location,\n            projectId: clientOptions.projectId,\n            authClient: clientOptions.authClient,\n            apiKey: clientOptions.apiKey,\n            signal: abortSignal,\n          };\n        }\n      }\n      if (clientOptions.kind == 'express') {\n        clientOpt.apiKey = calculateApiKey(\n          clientOptions.apiKey,\n          apiKeyFromConfig\n        );\n      } else if (apiKeyFromConfig) {\n        // Regional or Global can still use APIKey for billing (not auth)\n        clientOpt.apiKey = apiKeyFromConfig;\n      }\n\n      const labels = toGeminiLabels(labelsFromConfig);\n\n      const tools: Tool[] = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(toGeminiTool),\n        });\n      }\n\n      let toolConfig: ToolConfig | undefined;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: toGeminiFunctionModeEnum(functionCallingConfig.mode),\n          },\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: toGeminiFunctionModeEnum(request.toolChoice),\n          },\n        };\n      }\n\n      // Cannot use tools and function calling at the same time\n      const jsonMode =\n        (request.output?.format === 'json' || !!request.output?.schema) &&\n        tools.length === 0;\n\n      if (toolsFromConfig) {\n        tools.push(...(toolsFromConfig as any[]));\n      }\n\n      if (googleSearchRetrieval) {\n        // Gemini 1.5 models use googleSearchRetrieval, newer models use googleSearch.\n        if (ref.name.startsWith('vertexai/gemini-1.5')) {\n          tools.push({\n            googleSearchRetrieval:\n              googleSearchRetrieval as GoogleSearchRetrieval,\n          } as GoogleSearchRetrievalTool);\n        } else {\n          tools.push({\n            googleSearch: googleSearchRetrieval as GoogleSearchRetrieval,\n          } as GoogleSearchRetrievalTool);\n        }\n      }\n\n      if (vertexRetrieval) {\n        const _projectId =\n          vertexRetrieval.datastore.projectId ||\n          (clientOptions.kind != 'express'\n            ? clientOptions.projectId\n            : undefined);\n        const _location =\n          vertexRetrieval.datastore.location ||\n          (clientOptions.kind == 'regional'\n            ? clientOptions.location\n            : undefined);\n        const _dataStoreId = vertexRetrieval.datastore.dataStoreId;\n        if (!_projectId || !_location || !_dataStoreId) {\n          throw new GenkitError({\n            status: 'INVALID_ARGUMENT',\n            message:\n              'projectId, location and datastoreId are required for vertexRetrieval and could not be determined from configuration',\n          });\n        }\n        const datastore = `projects/${_projectId}/locations/${_location}/collections/default_collection/dataStores/${_dataStoreId}`;\n        tools.push({\n          retrieval: {\n            vertexAiSearch: {\n              datastore,\n            },\n            disableAttribution: vertexRetrieval.disableAttribution,\n          },\n        });\n      }\n\n      const generateContentRequest: GenerateContentRequest = {\n        systemInstruction,\n        generationConfig: {\n          ...restOfConfig,\n          candidateCount: request.candidates || undefined,\n          responseMimeType: jsonMode ? 'application/json' : undefined,\n        },\n        tools,\n        toolConfig,\n        safetySettings: toGeminiSafetySettings(safetySettings),\n        contents: messages.map((message) => toGeminiMessage(message, ref)),\n        labels,\n      };\n\n      const modelVersion = versionFromConfig || extractVersion(ref);\n\n      if (jsonMode && request.output?.constrained) {\n        generateContentRequest.generationConfig!.responseSchema = cleanSchema(\n          request.output.schema\n        );\n      }\n\n      const callGemini = async () => {\n        let response: GenerateContentResponse;\n\n        // Handle streaming and non-streaming responses\n        if (streamingRequested) {\n          const result = await generateContentStream(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n\n          for await (const item of result.stream) {\n            (item as GenerateContentResponse).candidates?.forEach(\n              (candidate) => {\n                const c = fromGeminiCandidate(candidate);\n                sendChunk({\n                  index: c.index,\n                  content: c.message.content,\n                });\n              }\n            );\n          }\n          response = await result.response;\n        } else {\n          response = await generateContent(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n\n        if (!response.candidates?.length) {\n          throw new GenkitError({\n            status: 'FAILED_PRECONDITION',\n            message: 'No valid candidates returned.',\n          });\n        }\n\n        const candidateData = response.candidates.map((c) =>\n          fromGeminiCandidate(c)\n        );\n\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...getBasicUsageStats(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens:\n              response.usageMetadata?.cachedContentTokenCount,\n          },\n        };\n      };\n\n      // If debugTraces is enabled, we wrap the actual model call with a span,\n      // add raw API params as for input.\n      const msg = toGeminiMessage(messages[messages.length - 1], ref);\n      return pluginOptions?.experimental_debugTraces\n        ? await runInNewSpan(\n            ai.registry,\n            {\n              metadata: {\n                name: streamingRequested ? 'sendMessageStream' : 'sendMessage',\n              },\n            },\n            async (metadata) => {\n              metadata.input = {\n                apiEndpoint: getVertexAIUrl({\n                  includeProjectAndLocation: false,\n                  resourcePath: '',\n                  clientOptions: clientOpt,\n                }),\n                cache: {},\n                model: modelVersion,\n                generateContentOptions: generateContentRequest,\n                parts: msg.parts,\n                options: clientOpt,\n              };\n              const response = await callGemini();\n              metadata.output = response.custom;\n              return response;\n            }\n          )\n        : await callGemini();\n    }\n  );\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":["import_converters"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4247, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/imagen.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionMetadata, Genkit, modelActionMetadata, z } from 'genkit';\nimport {\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelReference,\n  modelRef,\n} from 'genkit/model';\nimport { imagenPredict } from './client.js';\nimport { fromImagenResponse, toImagenPredictRequest } from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport { checkModelName, extractVersion, modelName } from './utils.js';\n\n/**\n * See https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api.\n */\nexport const ImagenConfigSchema = GenerationCommonConfigSchema.extend({\n  // TODO: Remove common config schema extension since Imagen models don't support\n  // most of the common config parameters. Also, add more parameters like sampleCount\n  // from the above reference.\n  language: z\n    .enum(['auto', 'en', 'es', 'hi', 'ja', 'ko', 'pt', 'zh-TW', 'zh', 'zh-CN'])\n    .describe('Language of the prompt text.')\n    .optional(),\n  aspectRatio: z\n    .enum(['1:1', '9:16', '16:9', '3:4', '4:3'])\n    .describe('Desired aspect ratio of the output image.')\n    .optional(),\n  negativePrompt: z\n    .string()\n    .describe(\n      'A description of what to discourage in the generated images. ' +\n        'For example: \"animals\" (removes animals), \"blurry\" ' +\n        '(makes the image clearer), \"text\" (removes text), or ' +\n        '\"cropped\" (removes cropped images).'\n    )\n    .optional(),\n  seed: z\n    .number()\n    .int()\n    .min(1)\n    .max(2147483647)\n    .describe(\n      'Controls the randomization of the image generation process. Use the ' +\n        'same seed across requests to provide consistency, or change it to ' +\n        'introduce variety in the response.'\n    )\n    .optional(),\n  location: z\n    .string()\n    .describe('Google Cloud region e.g. us-central1.')\n    .optional(),\n  personGeneration: z\n    .enum(['dont_allow', 'allow_adult', 'allow_all'])\n    .describe('Control if/how images of people will be generated by the model.')\n    .optional(),\n  safetySetting: z\n    .enum(['block_most', 'block_some', 'block_few', 'block_fewest'])\n    .describe('Adds a filter level to safety filtering.')\n    .optional(),\n  addWatermark: z\n    .boolean()\n    .describe('Add an invisible watermark to the generated images.')\n    .optional(),\n  storageUri: z\n    .string()\n    .describe('Cloud Storage URI to store the generated images.')\n    .optional(),\n  mode: z\n    .enum(['upscale'])\n    .describe('Mode must be set for upscaling requests.')\n    .optional(),\n  /**\n   * Describes the editing intention for the request.\n   *\n   * See https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api#edit_images_2 for details.\n   */\n  editConfig: z\n    .object({\n      editMode: z\n        .enum([\n          'inpainting-insert',\n          'inpainting-remove',\n          'outpainting',\n          'product-image',\n        ])\n        .describe('Editing intention for the request.')\n        .optional(),\n      maskMode: z\n        .object({\n          maskType: z\n            .enum(['background', 'foreground', 'semantic'])\n            .describe(\n              '\"background\" automatically generates a mask for all ' +\n                'regions except the primary subject(s) of the image, ' +\n                '\"foreground\" automatically generates a mask for the primary ' +\n                'subjects(s) of the image. \"semantic\" segments one or more ' +\n                'of the segmentation classes using class ID.'\n            ),\n          classes: z\n            .array(z.number())\n            .describe('List of class IDs for segmentation.')\n            .length(5)\n            .optional(),\n        })\n        .describe(\n          'Prompts the model to generate a mask instead of you ' +\n            'needing to provide one. Consequently, when you provide ' +\n            'this parameter you can omit a mask object.'\n        )\n        .optional(),\n      maskDilation: z\n        .number()\n        .describe('Dilation percentage of the mask provided.')\n        .min(0.0)\n        .max(1.0)\n        .optional(),\n      guidanceScale: z\n        .number()\n        .describe(\n          'Controls how much the model adheres to the text prompt. ' +\n            'Large values increase output and prompt alignment, but may ' +\n            'compromise image quality. Suggested values are 0-9 ' +\n            '(low strength), 10-20 (medium strength), 21+ (high strength).'\n        )\n        .optional(),\n      productPosition: z\n        .enum(['reposition', 'fixed'])\n        .describe(\n          'Defines whether the product should stay fixed or be ' +\n            'repositioned.'\n        )\n        .optional(),\n    })\n    .passthrough()\n    .optional(),\n  upscaleConfig: z\n    .object({\n      upscaleFactor: z\n        .enum(['x2', 'x4'])\n        .describe('The factor to upscale the image.'),\n    })\n    .describe('Configuration for upscaling.')\n    .optional(),\n}).passthrough();\nexport type ImagenConfigSchemaType = typeof ImagenConfigSchema;\nexport type ImagenConfig = z.infer<ImagenConfigSchemaType>;\n\n// for commonRef\ntype ConfigSchemaType = ImagenConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = ImagenConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\n// Allow all the capabilities for unknown future models\nconst GENERIC_MODEL = commonRef('imagen', {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: ['media'],\n  },\n});\n\nexport const KNOWN_MODELS = {\n  'imagen-3.0-generate-002': commonRef('imagen-3.0-generate-002'),\n  'imagen-3.0-generate-001': commonRef('imagen-3.0-generate-001'),\n  'imagen-3.0-capability-001': commonRef('imagen-3.0-capability-001'),\n  'imagen-3.0-fast-generate-001': commonRef('imagen-3.0-fast-generate-001'),\n  'imagen-4.0-generate-preview-06-06': commonRef(\n    'imagen-4.0-generate-preview-06-06'\n  ),\n  'imagen-4.0-ultra-generate-preview-06-06': commonRef(\n    'imagen-4.0-ultra-generate-preview-06-06'\n  ),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS;\nexport type ImagenModelName = `imagen=${string}`;\nexport function isImagenModelName(value?: string): value is ImagenModelName {\n  return !!value?.startsWith('imagen-');\n}\n\nexport function model(\n  version: string,\n  config: ImagenConfig = {}\n): ModelReference<typeof ImagenConfigSchema> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isImagenModelName(modelName(m.name)))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function defineKnownModels(\n  ai: Genkit,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\n\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n\n  return ai.defineModel(\n    {\n      apiVersion: 'v2',\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const imagenPredictRequest = toImagenPredictRequest(request);\n\n      const response = await imagenPredict(\n        extractVersion(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      return fromImagenResponse(response, request);\n    }\n  );\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4471, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/lyria.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  Genkit,\n  modelActionMetadata,\n  modelRef,\n  ModelReference,\n  z,\n} from 'genkit';\nimport { ModelAction, ModelInfo } from 'genkit/model';\nimport { lyriaPredict } from './client.js';\nimport { fromLyriaResponse, toLyriaPredictRequest } from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport { checkModelName, extractVersion } from './utils.js';\n\nexport const LyriaConfigSchema = z\n  .object({\n    negativePrompt: z\n      .string()\n      .optional()\n      .describe(\n        'Optional. A description of what to exclude from the generated audio.'\n      ),\n    seed: z\n      .number()\n      .optional()\n      .describe(\n        'Optional. A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters. Cannot be used with sample_count in the same request.'\n      ),\n    sampleCount: z\n      .number()\n      .optional()\n      .describe(\n        'Optional. The number of audio samples to generate. Default is 1 if not specified and seed is not used. Cannot be used with seed in the same request.'\n      ),\n  })\n  .passthrough();\nexport type LyriaConfigSchemaType = typeof LyriaConfigSchema;\nexport type LyriaConfig = z.infer<LyriaConfigSchemaType>;\n\ntype ConfigSchemaType = LyriaConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = LyriaConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('lyria');\n\nconst KNOWN_MODELS = {\n  'lyria-002': commonRef('lyria-002'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocorrect\nexport type LyriaModelName = `lyria-${string}`;\nexport function isLyriaModelName(value?: string): value is LyriaModelName {\n  return !!value?.startsWith('lyria-');\n}\n\nexport function model(\n  version: string,\n  config: LyriaConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: LyriaConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isLyriaModelName(m.name))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function defineKnownModels(\n  ai: Genkit,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\n\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n\n  return ai.defineModel(\n    {\n      apiVersion: 'v2',\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const lyriaPredictRequest = toLyriaPredictRequest(request);\n\n      const response = await lyriaPredict(\n        extractVersion(ref),\n        lyriaPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      return fromLyriaResponse(response, request);\n    }\n  );\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4603, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/veo.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  ModelReference,\n  modelActionMetadata,\n  modelRef,\n  z,\n  type Genkit,\n} from 'genkit';\nimport { BackgroundModelAction, ModelInfo } from 'genkit/model';\nimport { veoCheckOperation, veoPredict } from './client.js';\nimport {\n  fromVeoOperation,\n  toVeoModel,\n  toVeoOperationRequest,\n  toVeoPredictRequest,\n} from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport { checkModelName, extractVersion } from './utils.js';\n\nexport const VeoConfigSchema = z\n  .object({\n    sampleCount: z.number().optional().describe('Number of output videos'),\n    storageUri: z\n      .string()\n      .optional()\n      .describe('The gcs bucket where to save the generated videos'),\n    fps: z\n      .number()\n      .optional()\n      .describe('Frames per second for video generation'),\n    durationSeconds: z\n      .number()\n      .optional()\n      .describe('Duration of the clip for video generation in seconds'),\n    seed: z\n      .number()\n      .optional()\n      .describe(\n        'The RNG seed. If RNG seed is exactly same for each request with unchanged ' +\n          'inputs, the prediction results will be consistent. Otherwise, a random RNG ' +\n          'seed will be used each time to produce a different result. If the sample ' +\n          'count is greater than 1, random seeds will be used for each sample.'\n      ),\n    aspectRatio: z\n      .enum(['9:16', '16:9'])\n      .optional()\n      .describe('The aspect ratio for the generated video'),\n    resolution: z\n      .enum(['720p', '1080p'])\n      .optional()\n      .describe('The resolution for the generated video'),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .optional()\n      .describe(\n        'Specifies the policy for generating persons in videos, including age restrictions'\n      ),\n    pubsubTopic: z\n      .string()\n      .optional()\n      .describe('The pubsub topic to publish the video generation progress to'),\n    negativePrompt: z\n      .string()\n      .optional()\n      .describe(\n        'In addition to the text context, negative prompts can be explicitly stated here to help generate the video'\n      ),\n    enhancePrompt: z\n      .boolean()\n      .optional()\n      .describe(\n        'If true, the prompt will be improved before it is used to generate videos. ' +\n          'The RNG seed, if provided, will not result in consistent results if prompts are enhanced.'\n      ),\n    generateAudio: z\n      .boolean()\n      .optional()\n      .describe('If true, audio will be generated along with the video'),\n    compressionQuality: z\n      .enum(['optimized', 'lossless'])\n      .default('optimized')\n      .optional()\n      .describe('Compression quality of the generated video'),\n  })\n  .passthrough();\nexport type VeoConfigSchemaType = typeof VeoConfigSchema;\nexport type VeoConfig = z.infer<VeoConfigSchemaType>;\n\n// This contains all the Veo config schema types\ntype ConfigSchemaType = VeoConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = VeoConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info:\n      info ??\n      ({\n        supports: {\n          media: true,\n          multiturn: false,\n          tools: false,\n          systemRole: false,\n          output: ['media'],\n          longRunning: true,\n        },\n      } as ModelInfo), // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\n\nconst GENERIC_MODEL = commonRef('veo');\n\nconst KNOWN_MODELS = {\n  'veo-2.0-generate-001': commonRef('veo-2.0-generate-001'),\n  'veo-3.0-generate-001': commonRef('veo-3.0-generate-001'),\n  'veo-3.0-fast-generate-001': commonRef('veo-3.0-fast-generate-001'),\n  'veo-3.0-generate-preview': commonRef('veo-3.0-generate-preview'),\n  'veo-3.0-fast-generate-preview': commonRef('veo-3.0-fast-generate-preview'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\nexport type VeoModelName = `veo-${string}`;\nexport function isVeoModelName(value?: string): value is VeoModelName {\n  return !!value?.startsWith('veo-');\n}\n\nexport function model(\n  version: string,\n  config: VeoConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Veo models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isVeoModelName(m.name))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function defineKnownModels(\n  ai: Genkit,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  for (const name of Object.keys(KNOWN_MODELS)) {\n    defineModel(ai, name, clientOptions, pluginOptions);\n  }\n}\n\nexport function defineModel(\n  ai: Genkit,\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): BackgroundModelAction<VeoConfigSchemaType> {\n  const ref = model(name);\n\n  return ai.defineBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const veoPredictRequest = toVeoPredictRequest(request);\n\n      const response = await veoPredict(\n        extractVersion(ref),\n        veoPredictRequest,\n        clientOptions\n      );\n\n      return fromVeoOperation(response);\n    },\n    async check(operation) {\n      const response = await veoCheckOperation(\n        toVeoModel(operation),\n        toVeoOperationRequest(operation),\n        clientOptions\n      );\n      return fromVeoOperation(response);\n    },\n  });\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4760, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/vertexai/index.ts"],"sourcesContent":["/**\n * @license\n *\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @module /\n */\n\nimport { EmbedderReference, Genkit, ModelReference, z } from 'genkit';\nimport { GenkitPlugin, genkitPlugin } from 'genkit/plugin';\nimport { ActionType } from 'genkit/registry';\nimport { listModels } from './client.js';\n\nimport * as embedder from './embedder.js';\nimport * as gemini from './gemini.js';\nimport * as imagen from './imagen.js';\nimport * as lyria from './lyria.js';\nimport * as veo from './veo.js';\n\nimport { VertexPluginOptions } from './types.js';\nimport { getDerivedOptions } from './utils.js';\n\nexport { type EmbeddingConfig } from './embedder.js';\nexport { type GeminiConfig } from './gemini.js';\nexport { type ImagenConfig } from './imagen.js';\nexport { type LyriaConfig } from './lyria.js';\nexport { type VertexPluginOptions } from './types.js';\nexport { type VeoConfig } from './veo.js';\n\nasync function initializer(ai: Genkit, pluginOptions?: VertexPluginOptions) {\n  const clientOptions = await getDerivedOptions(pluginOptions);\n  veo.defineKnownModels(ai, clientOptions, pluginOptions);\n  imagen.defineKnownModels(ai, clientOptions, pluginOptions);\n  lyria.defineKnownModels(ai, clientOptions, pluginOptions);\n  gemini.defineKnownModels(ai, clientOptions, pluginOptions);\n  embedder.defineKnownModels(ai, clientOptions, pluginOptions);\n}\n\nasync function resolver(\n  ai: Genkit,\n  actionType: ActionType,\n  actionName: string,\n  pluginOptions?: VertexPluginOptions\n) {\n  const clientOptions = await getDerivedOptions(pluginOptions);\n  switch (actionType) {\n    case 'model':\n      if (lyria.isLyriaModelName(actionName)) {\n        lyria.defineModel(ai, actionName, clientOptions, pluginOptions);\n      } else if (imagen.isImagenModelName(actionName)) {\n        imagen.defineModel(ai, actionName, clientOptions, pluginOptions);\n      } else if (veo.isVeoModelName(actionName)) {\n        // no-op (not gemini)\n      } else {\n        gemini.defineModel(ai, actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case 'background-model':\n      if (veo.isVeoModelName(actionName)) {\n        veo.defineModel(ai, actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case 'embedder':\n      embedder.defineEmbedder(ai, actionName, clientOptions, pluginOptions);\n      break;\n    default:\n    // no-op\n  }\n}\n\nasync function listActions(options?: VertexPluginOptions) {\n  try {\n    const clientOptions = await getDerivedOptions(options);\n    const models = await listModels(clientOptions);\n    return [\n      ...gemini.listActions(models),\n      ...imagen.listActions(models),\n      ...lyria.listActions(models),\n      ...veo.listActions(models),\n      // We don't list embedders here\n    ];\n  } catch (e: unknown) {\n    // Errors are already logged in the client code.\n    return [];\n  }\n}\n\n/**\n * Add Google Cloud Vertex AI to Genkit. Includes Gemini and Imagen models and text embedder.\n */\nfunction vertexAIPlugin(options?: VertexPluginOptions): GenkitPlugin {\n  let listActionsCache;\n  return genkitPlugin(\n    'vertexai',\n    async (ai: Genkit) => await initializer(ai, options),\n    async (ai: Genkit, actionType: ActionType, actionName: string) =>\n      await resolver(ai, actionType, actionName, options),\n    async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    }\n  );\n}\n\nexport type VertexAIPlugin = {\n  (pluginOptions?: VertexPluginOptions): GenkitPlugin;\n  model(\n    name: gemini.KnownModels | (gemini.GeminiModelName & {}),\n    config?: gemini.GeminiConfig\n  ): ModelReference<gemini.GeminiConfigSchemaType>;\n  model(\n    name: imagen.KnownModels | (imagen.ImagenModelName & {}),\n    config?: imagen.ImagenConfig\n  ): ModelReference<imagen.ImagenConfigSchemaType>;\n  model(\n    name: lyria.KnownModels | (lyria.LyriaModelName & {}),\n    config: lyria.LyriaConfig\n  ): ModelReference<lyria.LyriaConfigSchemaType>;\n  model(\n    name: veo.KnownModels | (veo.VeoModelName & {}),\n    config: veo.VeoConfig\n  ): ModelReference<veo.VeoConfigSchemaType>;\n  model(name: string, config?: any): ModelReference<z.ZodTypeAny>;\n\n  embedder(\n    name: string,\n    config?: embedder.EmbeddingConfig\n  ): EmbedderReference<embedder.EmbeddingConfigSchemaType>;\n};\n\n/**\n * Google Cloud Vertex AI plugin for Genkit.\n * Includes Gemini and Imagen models and text embedder.\n */\nexport const vertexAI = vertexAIPlugin as VertexAIPlugin;\n// provide generic implementation for the model function overloads.\n(vertexAI as any).model = (\n  name: string,\n  config?: any\n): ModelReference<z.ZodTypeAny> => {\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  if (lyria.isLyriaModelName(name)) {\n    return lyria.model(name, config);\n  }\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  // gemini and unknown model families\n  return gemini.model(name, config);\n};\nvertexAI.embedder = (\n  name: string,\n  config?: embedder.EmbeddingConfig\n): EmbedderReference<embedder.EmbeddingConfigSchemaType> => {\n  return embedder.model(name, config);\n};\n\nexport default vertexAI;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4903, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/%40genkit-ai/google-genai/src/index.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport {\n  googleAI,\n  type EmbeddingConfig,\n  type GeminiConfig,\n  type GeminiTtsConfig,\n  type GoogleAIPluginOptions,\n  type ImagenConfig,\n} from './googleai/index.js';\nexport { vertexAI } from './vertexai/index.js';\n"],"names":[],"mappings":";AAgBA;AAQA,SAAS,gBAAgB","ignoreList":[0],"debugId":null}}]
}